<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/11/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-10-10T19:01:03.483Z" itemprop="datePublished">2024-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/11/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/11/hello-world/" data-id="cm23ox8tb0000x22z37b0b3gi" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第2讲/贪心解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E8%AE%B2/%E8%B4%AA%E5%BF%83%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2024-09-26T07:05:38.000Z" itemprop="datePublished">2024-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="终极案例-—2881-接苹果"><a href="#终极案例-—2881-接苹果" class="headerlink" title="终极案例 —2881 接苹果"></a>终极案例 —2881 接苹果</h5><p><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_4a357b6b13-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158548454359.png" alt="企业微信截图_17158548454359.png"><br><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_626ea16a13-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158548846822.png" alt="企业微信截图_17158548846822.png"><br><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_662b315413-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158549023583.png" alt="企业微信截图_17158549023583.png"><br><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_6ada855f13-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158549181483.png" alt="企业微信截图_17158549181483.png"> </p>
<p>（题外话 可能与蚂蚁的那道题类似但写法截然不同）</p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>首先这道题是根据某个性质进行贪心。</p>
<p>第一步我们分析题目–如果奶牛能接到苹果恒等于t^1^-t$\geq$$|s^1-s|$ <strong>(批注：t^1^,s^1^是苹果的初始的时间和坐标，t,s是奶牛的，下文的恒等于都用&lt;&#x3D;&gt;代替。)</strong><br>我们将绝对值拆开，t^1^-t$\geq$$|s^1-s|$  &lt;&#x3D;&gt;   t^1^-t$\geq$max(s^1^-s,s-s^1^)   &lt;&#x3D;&gt;   </p>
<p>满足两个不等式   </p>
<h5 id="1-t-1-t-geq-s-1-s"><a href="#1-t-1-t-geq-s-1-s" class="headerlink" title="1.t^1^-t$\geq$s^1^-s"></a>1.t^1^-t$\geq$s^1^-s</h5><h5 id="2-t-1-t-geq-s-s-1"><a href="#2-t-1-t-geq-s-s-1" class="headerlink" title="2.t^1^-t$\geq$s-s^1^"></a>2.t^1^-t$\geq$s-s^1^</h5><p>继续化简&lt;&#x3D;&gt;</p>
<h5 id="1-t-1-s-1-geq-t-s"><a href="#1-t-1-s-1-geq-t-s" class="headerlink" title="1.t^1^-s^1^$\geq$t-s"></a>1.t^1^-s^1^$\geq$t-s</h5><h5 id="2-t-1-s-1-geq-t-s"><a href="#2-t-1-s-1-geq-t-s" class="headerlink" title="2.t^1^+s^1^$\geq$t+s"></a>2.t^1^+s^1^$\geq$t+s</h5><p>好，我们令 t-s&#x3D;x,t+s&#x3D;y。现在能看到性质了，<strong>如果某头牛能拿到某个苹果则x^1^$\geq$x且y^1^$\geq$y</strong>。</p>
<p><strong>则苹果被牛抓到的条件为(X^1^,Y^1^) $\in$[x,$\infty$)$\cap$[y,$\infty$)。</strong></p>
<p>好，得到这两个限制条件，可以通过对x或y任意一个排序来达到使其中一个必然满足，这边对y排序。</p>
<p>对y进行降序排序，如果y相同则对x进行降序排序。根据题目约束不可能存在两个相同的点，那么顺次枚举，如果是苹果就加入 <code>multiset</code>，如果是奶牛就 <code>lower_bound</code> 当前的 <code>multiset</code> 中最小的横坐标 ≥x 的点。不难发现总复杂度是 𝑂(𝑛log⁡𝑛) 的。</p>
<p>(晦涩难懂？那就换个图自己模拟一下就懂了)</p>
<p>晦涩点1，为什么不用管y？答：因为y是排好序的后面的必然能选前面但是x不是。</p>
<p>晦涩点2，为什么要lower_bound(x)？答：set里是按x排序的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span> &#123;<span class="type">int</span> q,x,y,n;&#125;op[N];</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(P a,P b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(P a,P b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x==b.x;</span><br><span class="line">&#125;</span><br><span class="line">multiset&lt;P&gt;apple;</span><br><span class="line">multiset&lt;P&gt;::iterator it;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.y==b.y?a.x&gt;b.x:a.y&gt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,t,x;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;op[i].q&gt;&gt;t&gt;&gt;x&gt;&gt;op[i].n;</span><br><span class="line">		op[i].x=t-x,op[i].y=t+x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(op<span class="number">+1</span>,op+n<span class="number">+1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(op[i].q==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span>(op[i].n)&#123;</span><br><span class="line">				it=apple.<span class="built_in">lower_bound</span>(op[i]);</span><br><span class="line">				<span class="keyword">if</span>(it==apple.<span class="built_in">end</span>())<span class="keyword">break</span>;</span><br><span class="line">				ans+=<span class="built_in">min</span>(op[i].n,it-&gt;n);</span><br><span class="line">				<span class="keyword">if</span>(op[i].n&lt;it-&gt;n)&#123;</span><br><span class="line">					P tmp=*it;</span><br><span class="line">					apple.<span class="built_in">erase</span>(it);</span><br><span class="line">					tmp.n-=op[i].n;</span><br><span class="line">					apple.<span class="built_in">insert</span>(tmp);</span><br><span class="line">					op[i].n=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(op[i].n==it-&gt;n)&#123;</span><br><span class="line">					op[i].n=<span class="number">0</span>;</span><br><span class="line">					apple.<span class="built_in">erase</span>(it);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					op[i].n-=it-&gt;n;</span><br><span class="line">					apple.<span class="built_in">erase</span>(it);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			apple.<span class="built_in">insert</span>(op[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E8%AE%B2/%E8%B4%AA%E5%BF%83%E8%A7%A3/" data-id="cm23pcg0v000i362z91qwdwdg" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第8讲/背包模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2024-09-26T06:10:50.000Z" itemprop="datePublished">2024-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="0-1背包问题介绍"><a href="#0-1背包问题介绍" class="headerlink" title="0-1背包问题介绍"></a>0-1背包问题介绍</h3><p>在0-1背包问题中，你有<strong>N</strong>件物品和一个容量为<strong>V</strong>的背包。每件物品都有各自的体积和价值，且每件物品只能选择一次。目标是在不超过背包容量的前提下，最大化装入背包的物品总价值。</p>
<h4 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h4><p>动态规划是一种通过分解问题、记住中间结果来解决复杂问题的方法。对于0-1背包问题，我们可以通过以下步骤使用动态规划求解：</p>
<ol>
<li><p><strong>状态定义</strong>：定义状态<code>f[i][j]</code>表示在前<strong>i</strong>个物品中，使用容量至多为<strong>j</strong>的背包时，能获得的最大价值。</p>
</li>
<li><p>m&#x3D;5,f[1][2];&#x2F;&#x2F;前1个物品，花费了两个容量获得的最大价值；f[2][3]</p>
</li>
<li><p><strong>状态转移方程</strong>：</p>
<ul>
<li><p>如果背包容量<strong>j</strong>小于第<strong>i</strong>件物品的体积<code>v[i]</code>，则第<strong>i</strong>件物品无法被选中，因此状态<code>f[i][j]</code>等于<code>f[i - 1][j]</code>。</p>
</li>
<li><p>如果背包容量足够，我们需要在携带和不携带第<strong>i</strong>件物品之间做出选择：</p>
<ul>
<li>携带第<strong>i</strong>件物品，价值为<code>f[i - 1][j - v[i]] + w[i]</code>。</li>
<li>不携带第<strong>i</strong>件物品，价值为<code>f[i - 1][j]</code>。</li>
</ul>
<p>​    我们选择两者中的最大值作为<code>f[i][j]</code>的值。</p>
</li>
</ul>
</li>
<li><p><strong>初始化和边界条件</strong>：<code>f[0][0] = 0</code>，表示没有物品或零容量时，价值为零。</p>
</li>
<li><p><strong>计算顺序</strong>：由于状态<code>f[i][j]</code>依赖于之前的状态，我们需要按照物品序号或背包容量的顺序进行计算。</p>
</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>提供了几种不同的代码实现方式：</p>
<h5 id="版本1：二维DP数组"><a href="#版本1：二维DP数组" class="headerlink" title="版本1：二维DP数组"></a>版本1：二维DP数组</h5><p>使用两个嵌套循环，外循环遍历物品，内循环遍历背包容量。这种方式需要一个二维数组来存储中间状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[MAXN];    <span class="comment">// 价值</span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int f[2][MAXN];</span></span><br><span class="line"><span class="comment">int cnt=0;</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">   for(int j=1;j&lt;=m;j++)&#123;</span></span><br><span class="line"><span class="comment">       if(j&lt;v[i])</span></span><br><span class="line"><span class="comment">       f[cnt][j]=f[1-cnt][j];</span></span><br><span class="line"><span class="comment">       else f[cnt][j]=max(f[1-cnt][j],f[1-cnt][j-v[i]]+w[i]);</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   cnt=1-cnt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i])</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="版本2：一维DP数组"><a href="#版本2：一维DP数组" class="headerlink" title="版本2：一维DP数组"></a>版本2：一维DP数组</h5><p>通过观察发现，我们只需要最终状态<code>f[n][m]</code>，因此可以将状态优化到一维数组<code>f[j]</code>。由于状态更新依赖于之前的决策，我们需要逆序遍历背包容量，以避免使用已经被更新的状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; v[i])</span><br><span class="line">            f[j] = f[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="版本3：优化输入"><a href="#版本3：优化输入" class="headerlink" title="版本3：优化输入"></a>版本3：优化输入</h5><p>进一步优化，我们可以在输入物品信息的同时进行状态更新，这样可以减 	少所需的存储空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN];  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;      <span class="comment">// 边输入边处理    </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>0-1背包问题是理解动态规划思想的一个很好的例子。通过定义清晰的阶段、状态和状态转移方程，以及合理地组织计算顺序，我们可以高效地解决这类问题。代码示例提供了从基础到优化的多种实现方法，有助于深入理解0-1背包问题的解决策略。</p>
<h3 id="完全背包问题概述"><a href="#完全背包问题概述" class="headerlink" title="完全背包问题概述"></a>完全背包问题概述</h3><p>完全背包问题是一种组合优化问题。你有<strong>N</strong>种不同的物品，每种物品都有无限件可用，以及一个容量为<strong>V</strong>的背包。每个物品都有一个体积<strong>vi</strong>和一个价值<strong>wi</strong>。目标是选择物品来装满背包，使得背包内的总体积不超过背包的容量，同时背包内的总价值最大。</p>
<h5 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h5><ul>
<li><strong>输入</strong>：第一行包含两个整数<strong>N</strong>和<strong>V</strong>，分别表示物品的数量和背包的容积。之后有<strong>N</strong>行，每行包含两个整数<strong>vi</strong>和<strong>wi</strong>，分别表示每种物品的体积和价值。</li>
<li><strong>输出</strong>：输出一个整数，表示能够装入背包的最大价值。</li>
</ul>
<h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><ul>
<li><strong>N</strong>, <strong>V</strong> ≤ 1000</li>
<li><strong>vi</strong>, <strong>wi</strong> ≤ 1000</li>
</ul>
<h4 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h4><p>完全背包问题可以使用动态规划解决。我们定义一个二维数组<strong>f[i][j]<strong>，其中</strong>f[i][j]<strong>表示在考虑前</strong>i</strong>种物品的情况下，背包容量为<strong>j</strong>时的最大价值。</p>
<p>状态转移方程如下：<br>$f[i][j] &#x3D; \max(f[i-1][j], f[i-1][j-k \cdot v[i]] + k \cdot w[i]) $<br>其中<strong>k</strong>是物品<strong>i</strong>的选取次数，且<strong>k</strong>可以从0到**j &#x2F; v[i]**。</p>
<h3 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h3><p>以下是代码的核心逻辑：</p>
<ol>
<li><p><strong>初始化</strong>：创建一个二维数组<strong>f</strong>，大小为<strong>N+1</strong> × <strong>M+1</strong>，用于存储动态规划过程中的中间结果。</p>
</li>
<li><p><strong>填充物品信息</strong>：遍历每种物品，读取其体积和价值。</p>
</li>
<li><p><strong>动态规划</strong>：使用嵌套循环，外循环遍历物品，内循环遍历背包容量。对于每个物品，我们检查所有可能的容量值，更新**f[i][j]**的值。</p>
</li>
<li><p><strong>状态更新</strong>：对于每个物品<strong>i</strong>和每个容量<strong>j</strong>，我们计算不选择物品<strong>i</strong>（即<strong>f[i-1][j]<strong>）和选择物品</strong>i</strong>多次（通过<strong>k</strong>循环）的最大价值，然后取两者的最大值作为**f[i][j]**的值。</p>
</li>
<li><p><strong>输出结果</strong>：最终，**f[N][V]**将包含最大价值，将其输出。</p>
</li>
</ol>
<h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>通过观察状态转移方程，我们可以发现不需要<strong>k</strong>循环，因为对于每个物品<strong>i</strong>和容量<strong>j</strong>，我们只需要考虑最后一次选择物品<strong>i</strong>的情况。这将问题简化为：<br>$ f[i][j] &#x3D; \max(f[i][j-v[i]] + w[i], f[i-1][j]) $</p>
<h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><p>最终的优化代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N], v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j++) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>完全背包问题通过动态规划可以有效解决。关键在于正确定义状态、状态转移方程，并进行适当的优化以提高算法效率。</p>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><p>多重背包是指每个物品有很多的数量。大概有三种方式，第一种是当作01背包写，第二种是通过二进制优化来枚举数量，第三种是&#x3D;&#x3D;单调队列优化&#x3D;&#x3D;。</p>
<p>19</p>
<p>1      1</p>
<p>2    10</p>
<p>4   100</p>
<p>8  1000</p>
<p>4</p>
<p>&#x3D;&#x3D;多重背包的单调队列优化在单调队列那章所讲&#x3D;&#x3D;</p>
<p>下面是朴素做法的代码</p>
<p>时间复杂度：O(n×m×s)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span><span class="number">+10</span>, M = <span class="number">6000</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i]; ++ k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - k * v[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="二进制优化的理解"><a href="#二进制优化的理解" class="headerlink" title="二进制优化的理解"></a>二进制优化的理解</h3><p><strong>二进制优化的必要性</strong>：<br>直接对每种物品的每种可能数量进行遍历将导致时间复杂度为O(n^3^)，这在大规模数据下是不可行的。二进制优化可以将时间复杂度降低到O(n^2^* logS)，其中S是每种物品数量的最大限制。</p>
<p><strong>二进制优化的核心思想</strong>：<br>利用二进制表示法来减少状态转移的复杂性。任何正整数都可以表示为二进制形式，即一系列2的幂的和。在多重背包问题中，这意味着每种物品的不同数量可以通过二进制表示来分解。</p>
<h3 id="二进制优化步骤"><a href="#二进制优化步骤" class="headerlink" title="二进制优化步骤"></a>二进制优化步骤</h3><ol>
<li><p><strong>分组</strong>：将每种物品的不同数量分为若干组，每组包含2的幂的数量。例如，如果一种物品最多可以选择10个，那么可以将其分为5组：1个、2个、4个、8个和剩余的数量。</p>
</li>
<li><p><strong>状态转移</strong>：对于每组物品，我们只需要考虑是否选择这组物品，而不是单个物品。这样，状态转移方程简化为类似于0-1背包问题的形式。</p>
</li>
<li><p><strong>计算最大价值</strong>：通过一维动态规划数组，从背包容量为0开始向上更新，直到达到最大容量。</p>
</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>二进制优化的C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12010</span>, M = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N]; <span class="comment">// 逐一枚举最大是N*logS</span></span><br><span class="line"><span class="type">int</span> f[M]; <span class="comment">// 体积&lt;M</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 分组的组别</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>; <span class="comment">// 组别里面的个数</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt;= s) &#123;</span><br><span class="line">            cnt++; <span class="comment">// 分组增加</span></span><br><span class="line">            v[cnt] = a * k; <span class="comment">// 整体体积</span></span><br><span class="line">            w[cnt] = b * k; <span class="comment">// 整体价值</span></span><br><span class="line">            s -= k; <span class="comment">// s减小</span></span><br><span class="line">            k *= <span class="number">2</span>; <span class="comment">// 组别里的个数增加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩余的一组</span></span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = cnt; <span class="comment">// 枚举次数由个数变成组别数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 01背包一维优化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二进制优化是一种有效的策略，用于解决多重背包问题中的大规模数据。通过将每种物品的不同数量分组，并利用二进制表示法来减少状态转移的复杂性，我们可以显著提高算法的效率。这种方法将问题转化为多个0-1背包问题的实例，每个实例对应于一组特定数量的物品，从而简化了问题并减少了计算量。</p>
<p>f[i]&#x3D;&#x3D;f[i][x]</p>
<p>f[i][x]&#x3D;max(f[i][x-1],f[i+(1&lt;&lt;(x-1))][x-1])</p>
<p>x&#x3D;log(m)</p>
<h3 id="混合背包问题概述"><a href="#混合背包问题概述" class="headerlink" title="混合背包问题概述"></a>混合背包问题概述</h3><p>在混合背包问题中，有<strong>N</strong>种物品和一个容量为<strong>V</strong>的背包。物品分为三类：</p>
<ol>
<li><strong>第一类</strong>：只能用1次（0-1背包问题）。</li>
<li><strong>第二类</strong>：可以用无限次（完全背包问题）。</li>
<li><strong>第三类</strong>：最多只能用<strong>si</strong>次（多重背包问题）。</li>
</ol>
<p>每种物品的体积是<strong>vi</strong>，价值是<strong>wi</strong>。问题的目标是选择物品装入背包，使得物品体积总和不超过背包容量，且价值总和最大。</p>
<h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p>状态<strong>f(i,j)<strong>表示从前</strong>i</strong>个物品中选取，总体积不超过<strong>j</strong>的所有选法的集合。</p>
<h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p>根据不同的物品类型，状态转移方程如下：</p>
<ul>
<li><strong>0-1背包</strong>：$f(i,j) &#x3D; \max(f(i-1,j), f(i-1,j-v)+w) $。</li>
<li><strong>完全背包</strong>：$f(i,j) &#x3D; \max(f(i-1,j), f(i,j-v)+w) $。</li>
<li><strong>多重背包</strong>：$ f(i,j) &#x3D; \max(f(i-1,j), f(i-1,j-v)+w, f(i-1,j-2v)+2w, \ldots) $。</li>
</ul>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>混合背包问题的时间复杂度为 $ O(N \times V \times \sum log_2 s_i) $，其中<strong>si</strong>是第三类物品的使用次数限制。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>以下是混合背包问题的C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, f[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (!s) &#123; <span class="comment">// 完全背包问题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = v; j &lt;= m; j++) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">-1</span>) s = <span class="number">1</span>; <span class="comment">// 0-1背包问题</span></span><br><span class="line">            <span class="comment">// 完全背包问题转化为01背包问题，二进制拆分优化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k *= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= k * v; j--) &#123;</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - k * v] + k * w);</span><br><span class="line">                &#125;</span><br><span class="line">                s -= k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= s * v; j--) &#123;</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - s * v] + s * w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>混合背包问题通过结合不同类型的背包问题，提供了一个更为通用的框架来处理背包问题的各种变体。通过适当的状态转移和优化，可以有效地解决这类问题，并找到最大价值的解决方案。</p>
<h3 id="分组背包问题概述"><a href="#分组背包问题概述" class="headerlink" title="分组背包问题概述"></a>分组背包问题概述</h3><p>分组背包问题是一种特殊的背包问题，其中物品被分为<strong>N</strong>组，每组内的物品可以看作是相似的，但每组内只能选择一个物品。每个物品有特定的体积<strong>vij</strong>和价值<strong>wij</strong>，其中<strong>i</strong>是组号，<strong>j</strong>是组内物品的编号。目标是选择一些物品装入容量为<strong>V</strong>的背包，使得总体积不超过背包容量，同时总价值最大。</p>
<h4 id="状态表示-1"><a href="#状态表示-1" class="headerlink" title="状态表示"></a>状态表示</h4><p>状态<strong>f(i,j)<strong>表示从前</strong>i</strong>个组中选取，且总体积不超过<strong>j</strong>的所有选法的集合。</p>
<h4 id="状态计算-1"><a href="#状态计算-1" class="headerlink" title="状态计算"></a>状态计算</h4><p>状态转移方程如下：</p>
<ol>
<li>如果不选择第<strong>i</strong>组中的任何物品，状态转移为**f(i-1,j)**。</li>
<li>如果选择第<strong>i</strong>组中的第<strong>k</strong>个物品，状态转移为<strong>f(i-1,j-vij)+wij</strong>。</li>
</ol>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>由于需要对每组内的物品进行遍历，并对每组使用一次背包问题的状态转移，时间复杂度为<strong>O(N×V×S)<strong>，其中</strong>S</strong>是每组内物品的数量。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>以下是分组背包问题的C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[N][N], w[N][N], f[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) &#123;</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++) &#123; <span class="comment">// 组内编号</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= v[i][k]) &#123;</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分组背包问题通过将物品分组，并在每组内独立应用背包问题的状态转移，可以有效地找到最大价值的解决方案。这种方法允许我们处理更为复杂的背包问题变体，其中物品的选择受到组内限制。通过适当的状态转移和优化，可以提高算法的效率，解决实际问题。</p>
<h3 id="0-1背包问题求方案数概述"><a href="#0-1背包问题求方案数概述" class="headerlink" title="0-1背包问题求方案数概述"></a>0-1背包问题求方案数概述</h3><p>在0-1背包问题中，给定<strong>N</strong>件物品和一个容量为<strong>V</strong>的背包。每件物品只能使用一次，每件物品的体积是<strong>vi</strong>，价值是<strong>wi</strong>。除了求解最大价值外，我们还希望找到所有可能的最优解方案数。</p>
<h4 id="状态表示-2"><a href="#状态表示-2" class="headerlink" title="状态表示"></a>状态表示</h4><ul>
<li><strong>f(i,j)</strong> 表示从<strong>i</strong>个物品中选择，且总体积不超过<strong>j</strong>时的最大价值。</li>
<li><strong>cnt(i,j)</strong> 表示从<strong>i</strong>个物品中选择，且总体积恰好为<strong>j</strong>时的方案数。</li>
</ul>
<h4 id="状态计算-2"><a href="#状态计算-2" class="headerlink" title="状态计算"></a>状态计算</h4><p>状态转移方程如下：</p>
<ul>
<li><strong>f(j)</strong> 更新为 <code>max(f(j), f(j-v)+w)</code>，其中 <strong>v</strong> 和 <strong>w</strong> 是当前考虑的物品体积和价值。</li>
<li><strong>cnt(j)</strong> 的更新取决于 <strong>f(j)</strong> 是如何更新的：<ul>
<li>如果 <strong>f(j)</strong> 通过不选择当前物品更新（即 **f(j) &#x3D; f(j-1)**），则 **cnt(j) &#x3D; cnt(j-1)**。</li>
<li>如果 <strong>f(j)</strong> 通过选择当前物品更新（即 <strong>f(j) &#x3D; f(j-v)+w</strong>），则 **cnt(j) &#x3D; cnt(j-v)**。</li>
<li>如果 <strong>f(j)</strong> 可以由两种方式得到，则 **cnt(j) &#x3D; cnt(j-1) + cnt(j-v)**。</li>
</ul>
</li>
</ul>
<h4 id="初始条件"><a href="#初始条件" class="headerlink" title="初始条件"></a>初始条件</h4><ul>
<li><strong>f(0)</strong> 初始化为0，表示没有任何物品时背包的价值为0。</li>
<li><strong>cnt(0)</strong> 初始化为1，表示空背包（不选择任何物品）是一种方案。</li>
</ul>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>算法的时间复杂度为 <strong>O(N×V)<strong>，其中 <strong>N</strong> 是物品数量，</strong>V</strong> 是背包容量。</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>以下是0-1背包问题求方案数的C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1100</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, f[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cnt[i] = <span class="number">1</span>; <span class="comment">// 初始化方案数，什么都不选是一种方案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[j] &lt; f[j - v] + w) &#123;</span><br><span class="line">                f[j] = f[j - v] + w;</span><br><span class="line">                cnt[j] = cnt[j - v];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f[j] == f[j - v] + w) &#123;</span><br><span class="line">                cnt[j] = (cnt[j] + cnt[j - v]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt[m] &lt;&lt; endl; <span class="comment">// 输出最优解的方案数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>0-1背包问题求方案数涉及到在找到最大价值的同时，记录和计算达到该价值的所有可能方案。通过维护一个额外的数组来跟踪方案数，我们可以在最终输出最优解的方案总数。这种方法可以应用于更复杂的背包问题变体，以提供关于最优解的更多信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/" data-id="cm23pcg0w000s362z7qhs0r8a" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第6讲/树状数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC6%E8%AE%B2/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2024-09-26T06:10:48.000Z" itemprop="datePublished">2024-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>树状数组（Binary Indexed Tree，简称BIT），是一种高效的数据结构，用于处理数组的加权前缀和问题。它提供了一种在对数时间内进行单点更新和前缀和查询的方法。以下是对树状数组的重新表述：</p>
<h3 id="树状数组简介"><a href="#树状数组简介" class="headerlink" title="树状数组简介"></a>树状数组简介</h3><p>单点更新 区间查询</p>
<p>例题：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240705132428612.png" alt="image-20240705132428612"></p>
<p>如果一个正整数x的二进制表示为$$ a_{k-1}a_{k-2}…a_{2}a_{1}a_{0} $$，其中为1的位是$${ a_{4}, a_{2}, …, a_{m} } $$，那么x可以分解为：<br>$$x &#x3D; 2^x + 2^y + … + 2^m $$<br>假设$$2^x &gt; 2^y &gt; … &gt; 2^m $$，那么区间[1, x)可以被分成$$\lfloor \log_2 x \rfloor $$个小区间，每个区间的长度对应于区间结束位置的最低位的1的2的幂次，即$$\text{lowbit}(R) $$。</p>
<p>例如，如果$$ x &#x3D; 7 &#x3D; 2^2 + 2^1 + 2^0 $$，区间[1, 7)可以被分成[1, 4]、[5, 6]和[7, 7]三个小区间，长度分别是$\text{lowbit}(4) &#x3D; 4 $、$ \text{lowbit}(6) &#x3D; 2 $$和 $$ \text{lowbit}(7) &#x3D; 1 $。</p>
<p>给定一个整数x，下面的代码可以计算出区间[1, x]被分成的$\lfloor \log_2 x \rfloor $个小区间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d, %d]\n&quot;</span>, x-(x &amp; -x) + <span class="number">1</span>, x);</span><br><span class="line">    x -= (x &amp; -x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树状数组（Binary Indexed Trees, BIT）是基于上述思想的数据结构，主要用于维护序列的前缀和。对于给定的序列$ \alpha $，我们建立一个数组c，其中 c[x]保存序列a 的区间$[x - \text{lowbit}(x) + 1, x] $中所有数的和。</p>
<p>数组c可4以看作是一个树形结构，其中每个内部节点c[x] 保存以它为根的子树中所有叶节点的和，且每个内部节点的子节点个数等于$\text{lowbit}(x) $的位数。除树根外，每个内部节点 c[x] 的父节点是$c[x + \text{lowbit}(x)] $。树的深度为$O(\lfloor \log_2 N \rfloor)\ $。</p>
<p>如果N不是2的整次幂，那么树状数组就是一个具有同样性质的森林结构。树状数组支持两个基本操作：</p>
<ol>
<li><p><strong>查询前缀和</strong>：查询序列a中第1到x个数的和，可以通过求出x的二进制表示中每个为1的位，将[1, x)分成$\lfloor \log_2 x \rfloor $   个小区间，并累加这些区间的和来实现。</p>
</li>
<li><p><strong>单点增加</strong>：给序列中的一个数( a[x] )加上y，并维护序列的前缀和。只有节点( c[x] )及其所有祖先节点保存的“区间和”包含[x]，逐一对它们的c值进行更新即可。</p>
</li>
</ol>
<p>初始化树状数组通常有两种方法：</p>
<ol>
<li><p>直接建立一个全为0的数组c，然后对每个位置x执行add(x, ax)，完成对原始序列a构造树状数组的过程，时间复杂度为O(N log N)。</p>
</li>
<li><p>更高效的初始化方法是：从小到大依次考虑每个节点x，借助lowbit运算扫描它的子节点并求和，时间复杂度为O(N)。</p>
</li>
</ol>
<p>树状数组通过这些操作，提供了一种在对数时间内进行单点更新和前缀和查询的高效方法。</p>
<p>树状数组是一种结合了前缀和概念的数据结构，它允许我们在对数时间内完成数组元素的更新和前缀和的查询。与传统的前缀和数组相比，树状数组在更新操作上更为高效。</p>
<h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>树状数组利用二进制表示法来划分数组中的前缀和。通过这种方式，树状数组能够快速定位到需要更新的位置，并在对数时间内完成操作。</p>
<p>图解：<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240526162334204.png" alt="image-20240526162334204" style="zoom:200%;" /></p>
<p>c[x]包含从x向前lowbit(x)个数据之后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">long long sum(int x) &#123;//log(x);//求1-x的数据之和</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    while (x &gt; 0) &#123;</span><br><span class="line">        ans += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">// 单点更新，将c[x]加上d</span><br><span class="line">void add(int x, int d) &#123;</span><br><span class="line">    while (x &lt;= n) &#123;</span><br><span class="line">        c[x] += d;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">求区间[l,r]数字之和，sum(r)-sum(l-1);</span><br><span class="line">更新，第4个数字加上一个3，add(4,3);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><p>树状数组可以直接使用数组进行存储，无需额外的数据结构。</p>
<h5 id="建立树状数组"><a href="#建立树状数组" class="headerlink" title="建立树状数组"></a>建立树状数组</h5><p>树状数组的建立过程相对简单，只需要初始化一个与待处理数组等长的数组即可。</p>
<p>未来能快速得到一个二进制的最后一位，我们用lowbit这个函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算x的最低位的1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="详细了解lowbit函数"><a href="#详细了解lowbit函数" class="headerlink" title="详细了解lowbit函数"></a>详细了解lowbit函数</h5><p><code>lowbit</code> 函数是一个在位运算中常用的小技巧，它用于找出一个整数的二进制表示中最低位的1。在编程和算法设计中，这个函数经常被用于优化与二进制位相关的操作。</p>
<h6 id="lowbit函数的定义"><a href="#lowbit函数的定义" class="headerlink" title="lowbit函数的定义"></a>lowbit函数的定义</h6><p>对于任意一个非负整数 <code>x</code>，<code>lowbit(x)</code> 表示的是 <code>x</code> 的二进制表示中最右边的非零位。例如：</p>
<ul>
<li><code>lowbit(10)</code> 的结果是2，因为10的二进制表示是 <code>1010</code>，最右边的1位于位置1，2^1^为2。</li>
<li><code>lowbit(7)</code> 的结果是1，因为7的二进制表示是 <code>111</code>，最右边的1位于位置0，2^0^为1。</li>
<li><code>lowbit(24)</code> 的结果是8，因为24的二进制是<code>11000</code>，最右边的1位于位置3，2^3^为8。</li>
</ul>
<h6 id="lowbit函数的实现"><a href="#lowbit函数的实现" class="headerlink" title="lowbit函数的实现"></a>lowbit函数的实现</h6><p>在C++或类似的语言中，<code>lowbit</code> 函数可以通过位运算来高效实现。以下是 <code>lowbit</code> 函数的一个可能的实现方式：</p>
<p>14-lowbit(14)&#x3D;12;</p>
<p>12-lowbit(12)&#x3D;8;</p>
<p>8-lowbit(8)&#x3D;0;</p>
<p>log(x)&lt;&#x3D;31;</p>
<p>lowbit(x);&#x2F;&#x2F;求出二进制x的末尾1所在2的次方</p>
<p>lowbit(16)&#x3D;16           16(10)&#x3D;16&#x3D;1000(2);</p>
<p>lowbit(14) &#x3D;2            14(10)&#x3D;8+4+2&#x3D;1110(2);</p>
<p>lowbit(12)&#x3D;4             12(10)&#x3D;8+4&#x3D;1100(2)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x; <span class="comment">// x和它的负数进行按位与操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>-x</code> 操作会将 <code>x</code> 的所有位取反（即从 <code>x</code> 的二进制表示中减去1），然后 <code>x &amp; -x</code> 操作会将最右边的1设置为0，其他位设置为0。这样，结果就是 <code>x</code> 中最低位的1。</p>
<h5 id="前缀和查询"><a href="#前缀和查询" class="headerlink" title="前缀和查询"></a>前缀和查询</h5><p>树状数组的前缀和查询操作是通过累加从查询位置到数组开始位置之间的所有标记过的值来实现的。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>以下是树状数组单点修改和前缀和查询的基本代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> c[N]; <span class="comment">// 树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算x的最低位的1  lowbit(7)=1  lowbit(8)=8  lowbit(6)=2 lowbit(12)=4 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 单点更新，将c[x]加上d</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] += d;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询前缀和，求1到x的和</span></span><br><span class="line"><span class="comment">//求区间[l,r]和，sum[r]-sum[l-1]两前缀和做差得到</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans += c[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树状数组因其高效的操作和简洁的实现，常被用于解决需要频繁更新和查询的问题，如数列的加权前缀和问题、区间更新问题等。</p>
<p><img src="https://cdn.acwing.com/media/article/image/2021/04/13/55909_2458a3c69c-%E5%A4%87%E6%B3%A8-2020%E5%B9%B47%E6%9C%8825%E6%97%A5.png" alt="备注 2020年7月25日.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC6%E8%AE%B2/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" data-id="cm23pcg0w000o362z7foxgw3x" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第7讲/线段树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/18/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC7%E8%AE%B2/%E7%BA%BF%E6%AE%B5%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2024-08-18T01:27:16.000Z" itemprop="datePublished">2024-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="线段树求和模板"><a href="#线段树求和模板" class="headerlink" title="线段树求和模板"></a>线段树求和模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线段树*/</span></span><br><span class="line"><span class="keyword">namespace</span> Segment_tree &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line">    <span class="type">int</span> nw[N];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tree</span> &#123;<span class="comment">//线段树存入结构体中</span></span><br><span class="line">        <span class="type">int</span> l, r;<span class="comment">//它所包含的区间[l,r]</span></span><br><span class="line">        LL sum, lazy;<span class="comment">//区间的和，以及懒标记下文会有注释</span></span><br><span class="line">    &#125; tr[N * <span class="number">4</span>];<span class="comment">//由于线段树的特性，我们开数组要为题目要求的四倍</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   懒标记的意思是每次修改后，先记下来哪个区间修改dd多少，只要我不差我就不改，这样能避免多次查询的复杂度</span></span><br><span class="line"><span class="comment">   比如说 我第一次 让[1,6]区间加上5，第二次让[2，8]区间加上8，不更新具体的值，然后这个每个区间上记录一下要更新多少，这样可避免[2,6]这个区间多次修改</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(tree &amp;u, tree &amp;l, tree &amp;r)</span> </span>&#123;</span><br><span class="line">        u.sum = l.sum + r.sum;</span><br><span class="line">        u.l = l.l, u.r = r.r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">push_up</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数build(1,1,n);</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;<span class="comment">//第一是数组的编号，然后是区间    构造一棵树，通过递归和回溯完成</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;<span class="comment">//如果l==r就是这个区间这包含一个点，那可以直接得出l,r,sum,lazy</span></span><br><span class="line">            tr[v] = &#123;l, l, nw[l], <span class="number">0</span>&#125;;<span class="comment">//lazy修改前，查完后都是0</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//取个中间值，把区间一分为二，分开建立子树</span></span><br><span class="line">        <span class="built_in">build</span>(v &lt;&lt; <span class="number">1</span>, l, mid);<span class="comment">//数组编号*2 放左区间  //这个做法可参考完全二叉树</span></span><br><span class="line">        <span class="built_in">build</span>(v &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);<span class="comment">//*2+1,放有区间</span></span><br><span class="line">        <span class="built_in">push_up</span>(v);<span class="comment">//回溯，是将两个子区间合并，来更新父节点的值，把比如父节点的sum是等于两个儿子的sum和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;<span class="comment">//这边主要是下放懒标记</span></span><br><span class="line">        <span class="keyword">if</span> (tr[u].lazy) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">            left.sum += tr[u].lazy * (left.r - left.l + <span class="number">1</span>);</span><br><span class="line">            right.sum += tr[u].lazy * (right.r - right.l + <span class="number">1</span>);</span><br><span class="line">            left.lazy += tr[u].lazy;</span><br><span class="line">            right.lazy += tr[u].lazy;</span><br><span class="line">            tr[u].lazy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//完全覆盖，[3,4]被[1,4],[1,9]完全覆盖</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;<span class="comment">//更新，让一个区间同意进行某个操作，u是数组编号</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) &#123;<span class="comment">//如果大于我这棵子树的范围 把它放到懒标记里，</span></span><br><span class="line">            tr[u].lazy += k;</span><br><span class="line">            tr[u].sum += (tr[u].r - tr[u].l + <span class="number">1</span>) * k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="comment">//部分覆盖</span></span><br><span class="line">        <span class="comment">//[3,10],当前线段树单元区间[2,5];</span></span><br><span class="line">        <span class="built_in">push_down</span>(u);<span class="comment">//否则就一分为二，向下递归，找到上述的递归结束条件</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)<span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)<span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="built_in">push_up</span>(u);<span class="comment">//更新后再向上回溯整理父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;<span class="comment">//查询类似于更新</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)<span class="comment">//如果lr包含了这棵子树就直接取值</span></span><br><span class="line">            <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">        <span class="built_in">push_down</span>(u);<span class="comment">//否则就往下查 查之前先下放懒标记，</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;<span class="comment">//一分为二向下递归找递归结束条件</span></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Segment_tree;</span><br><span class="line"><span class="comment">//------------------------//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="线段树简介"><a href="#线段树简介" class="headerlink" title="线段树简介"></a>线段树简介</h3><p>线段树是一种在算法竞赛中广泛使用的数据结构，它能够有效地维护区间信息。通过线段树，可以在较小的时间复杂度内完成单点修改、区间修改和区间查询操作，如区间求和、求最大值、最小值、GCD等。线段树维护的信息需要满足区间加法性质，即一个区间的信息可以通过两个子区间的信息合并得到。</p>
<h3 id="线段树的基本概念"><a href="#线段树的基本概念" class="headerlink" title="线段树的基本概念"></a>线段树的基本概念</h3><p>线段树是一种分治思想下的二叉搜索树，其所有操作都能在O(logn)时间复杂度内完成。线段树的特点包括：</p>
<ol>
<li>每个节点表示一个区间。</li>
<li>有一个唯一根节点，表示所有被统计的总区间，通常是[1, n]。</li>
<li>叶子节点表示的区间长度为1。</li>
<li>非叶子节点的左右子树分别表示左右两个子区间。</li>
<li>线段树的节点通常需要4倍于区间长度的空间。</li>
</ol>
<h3 id="线段树的存储方式"><a href="#线段树的存储方式" class="headerlink" title="线段树的存储方式"></a>线段树的存储方式</h3><p>线段树通常采用堆存储方式，根节点编号为1，非根节点x的父节点编号为⌊x&#x2F;2⌋，子节点编号分别为2x和2x+1。为防止节点编号超出存储范围，线段树通常需要4倍于n的空间。</p>
<p>sh</p>
<p>有一个十个元素的数组  我们要求区间和</p>
<p>求[2][8]</p>
<p>求[3,10]-&gt;[3,5],[6,10]</p>
<p>[3,5],-&gt;[3,3]+[4,5]</p>
<p>线段树每个节点都要有一个包含的区间[l,r]</p>
<p>int mid &#x3D;l+r&gt;&gt;1</p>
<p>[1,mid],[mid+1,r]</p>
<p>1 mid&#x3D;&#x3D;5</p>
<p>struct{</p>
<p>  l,r;</p>
<p>  sum;</p>
<p>lazy;&#x2F;&#x2F;这个区间我要给它加上lazy值 </p>
<p>}</p>
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240526165836248.png" alt="image-20240526165836248" style="zoom:200%;" /> 

<p>建立线段树的过程是递归的，从根节点开始，记录所有节点表示的区间。如果节点不是叶子节点，则递归建立左子树和右子树；如果是叶子节点，则记录区间和维护的信息，如数值本身。</p>
<p>下图是建立一棵寻找区间最大值的线段树，模板和上面的模板类似。</p>
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240526165924255.png" alt="image-20240526165924255" style="zoom:200%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct tree &#123;//线段树存入结构体中</span><br><span class="line">       int l, r;//它所包含的区间[l,r]</span><br><span class="line">       LL sum, lazy;//区间的和，以及懒标记下文会有注释</span><br><span class="line">   &#125; tr[N * 4];//由于线段树的特性，我们开数组要为题目要求的四倍</span><br><span class="line">  </span><br><span class="line">  void push_up(tree &amp;u, tree &amp;l, tree &amp;r) &#123;</span><br><span class="line">      u.sum = l.sum + r.sum;</span><br><span class="line">      //u.sum=max(l.sum,r.sum);//线段树求最大值</span><br><span class="line">       u.l = l.l, u.r = r.r;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   void push_up(int u) &#123;</span><br><span class="line">       push_up(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);</span><br><span class="line">   &#125;</span><br><span class="line">   入口：build(1,1,n)</span><br><span class="line">     void build(int v, int l, int r) &#123;//第一是数组的编号，然后是区间    构造一棵树，通过递归和回溯完成</span><br><span class="line">      if (l == r) &#123;//如果l==r就是这个区间这包含一个点，那可以直接得出l,r,sum,lazy</span><br><span class="line">           tr[v] = &#123;l, l, nw[l], 0&#125;;//lazy修改前，查完后都是0</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       int mid = l + r &gt;&gt; 1;//取个中间值，把区间一分为二，分开建立子树</span><br><span class="line">       build(v &lt;&lt; 1, l, mid);//数组编号*2 放左区间  //这个做法可参考完全二叉树</span><br><span class="line">       build(v &lt;&lt; 1 | 1, mid + 1, r);//*2+1,放有区间</span><br><span class="line">       push_up(v);//回溯，是将两个子区间合并，来更新父节点的值，把比如父节点的sum是等于两个儿子的sum和</span><br><span class="line">   &#125;</span><br><span class="line">    //回溯函数</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> in[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">9</span>)cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02d&quot;</span>,cnt);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(n-i)*<span class="number">2</span>;j++)cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02d&quot;</span>,cnt);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h3><p>懒标记是一种优化技术，用于在修改操作时延迟实际的修改，直到真正需要这些信息时才进行更新。懒标记的主要思想是，如果一个节点需要修改，那么它的所有子节点在未来也需要相同的修改，但实际的修改可以推迟到这些子节点被访问时进行。</p>
<h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>查询过程中，如果需要，会先分裂节点（即应用懒标记），然后递归查询左右子树。</p>
<p>线段树查询过程的时间复杂度是 (O(\log N))，这个复杂度来源于对询问区间 ([L, R]) 在线段树上的递归分割。以下是对查询过程的重新表述和解释：</p>
<p>当我们在线段树上执行区间查询时，会从根节点开始，根据询问区间与当前节点区间的相对位置，递归地将查询区间分割成更小的子区间，并在树中向下遍历。这个过程会产生 (O(\log N)) 个节点，每个节点代表一个子区间。下面是对这些节点情况的具体分析：</p>
<ol>
<li><p><strong>完全覆盖</strong>：如果当前节点的区间 ([P, P’]) 完全被询问区间 ([L, R]) 覆盖，即 $L \leq P \leq P’ \leq R$，那么我们可以直接返回这个节点的值作为答案。</p>
</li>
<li><p><strong>部分覆盖</strong>：如果询问区间只有一部分落在当前节点内，就需要继续递归查询子节点。</p>
<ul>
<li>如果 $P \leq L \leq P’ \leq R$，即左端点 (L) 在当前节点内，但右端点 (R) 不在，那么只有右子树需要被递归查询。</li>
<li>如果 $P \leq L \leq R \leq P’$，即询问区间从当前节点的左侧开始，但未完全覆盖当前节点，那么需要递归查询左右子树。特别是，右子节点会在递归后直接返回，因为它的区间完全在 ([L, R]) 内。</li>
</ul>
</li>
<li><p><strong>另一端点覆盖</strong>：与第二种情况类似，但是询问区间只有右端点 (R) 在当前节点内，处理方式与左端点在内时相同。</p>
</li>
<li><p><strong>两端点都在节点内</strong>：如果 $L \leq P $ 且 $P’ \leq R$，即询问区间的两端点都在当前节点内，会出现两种子情况：</p>
<ul>
<li>如果 L 和 R 都在中间节点 ([P, P’]) 的同一侧（即 $L \leq \text{mid} \leq R$ 或 $L \geq \text{mid} \geq R$），则只会递归查询一个子树。</li>
<li>如果 L 和R 分别位于中间节点 [P, P’] 的两侧（即 $L &lt; \text{mid} $ 且 $R &gt; \text{mid}$），则需要递归查询左右两个子树。</li>
</ul>
</li>
</ol>
<p>在所有这些情况中，只有当 (L) 和 (R) 分别位于中间节点两侧时（情况4(2)），会产生对左右两个子树的递归查询。这种情况在整个查询过程中最多发生一次，因为之后的任何递归都将处于情况2或3，只涉及单侧子树的查询。</p>
<p>从宏观角度理解，询问区间的左端点 (L) 和右端点 (R) 在线段树上各自划分出一条递归访问路径。情况4(2) 是这两条路径从下往上第一次交汇的地方，产生对左右子树的递归查询。因此，整个查询过程的时间复杂度是 (O(\log N))，这是因为 (L) 和 (R) 端点最多只能沿着树的高度递归，而树的高度是 (O(\log N))。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;<span class="comment">//查询类似于更新</span></span><br><span class="line">      <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r)<span class="comment">//如果lr包含了这棵子树就直接取值</span></span><br><span class="line">          <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">      <span class="built_in">push_down</span>(u);<span class="comment">//否则就往下查 查之前先下放懒标记，</span></span><br><span class="line">      <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;<span class="comment">//一分为二向下递归找递归结束条件</span></span><br><span class="line">      LL res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (l &lt;= mid)res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">      <span class="keyword">if</span> (r &gt; mid)res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//回溯函数</span></span><br><span class="line"><span class="comment">//下防懒标记函数 </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;<span class="comment">//这边主要是下放懒标记</span></span><br><span class="line">      <span class="keyword">if</span> (tr[u].lazy) &#123;</span><br><span class="line">          <span class="keyword">auto</span> &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">          left.sum += tr[u].lazy * (left.r - left.l + <span class="number">1</span>);</span><br><span class="line">          right.sum += tr[u].lazy * (right.r - right.l + <span class="number">1</span>);</span><br><span class="line">          left.lazy += tr[u].lazy;</span><br><span class="line">          right.lazy += tr[u].lazy;</span><br><span class="line">          tr[u].lazy = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>区间修改和区间查询类似区间修改分为两个步骤：</p>
<ol>
<li>找到线段树中表示全部被修改点的区间。</li>
<li>修改这些区间的所有点。</li>
</ol>
<p>区间修改的暴力版本时间复杂度为O(n)，但通过引入懒标记（lazy propagation）可以优化至O(logn)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;<span class="comment">//更新，让一个区间同意进行某个操作，u是数组编号</span></span><br><span class="line">      <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) &#123;<span class="comment">//如果大于我这棵子树的范围 把它放到懒标记里， [3,4]</span></span><br><span class="line">          tr[u].lazy += k;</span><br><span class="line">          tr[u].sum += (tr[u].r - tr[u].l + <span class="number">1</span>) * k;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">push_down</span>(u);<span class="comment">//否则就一分为二，向下递归，找到上述的递归结束条件</span></span><br><span class="line">      <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (l &lt;= mid)<span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">      <span class="keyword">if</span> (r &gt; mid)<span class="built_in">update</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">      <span class="built_in">push_up</span>(u);<span class="comment">//更新后再向上回溯整理父节点</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//回溯函数</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(tree &amp;u, tree &amp;l, tree &amp;r)</span> </span>&#123;</span><br><span class="line">      u.sum = l.sum + r.sum;</span><br><span class="line">      u.l = l.l, u.r = r.r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">push_up</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//下防懒标记函数 </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;<span class="comment">//这边主要是下放懒标记</span></span><br><span class="line">      <span class="keyword">if</span> (tr[u].lazy) &#123;</span><br><span class="line">          <span class="keyword">auto</span> &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">          left.sum += tr[u].lazy * (left.r - left.l + <span class="number">1</span>);</span><br><span class="line">          right.sum += tr[u].lazy * (right.r - right.l + <span class="number">1</span>);</span><br><span class="line">          left.lazy += tr[u].lazy;</span><br><span class="line">          right.lazy += tr[u].lazy;</span><br><span class="line">          tr[u].lazy = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>线段树（Segment Tree）是一种采用分治策略的二叉树数据结构，它允许我们在区间上进行信息的统计和处理。与树状数组不同，线段树不是基于二进制位划分区间的，而是一种更为通用的结构。以下是对线段树的重新表述：</p>
<p>线段树是一种二叉树结构，它将一个整体区间递归地划分为多个子区间。每个节点在树中代表一个区间，并且每个节点的子节点分别代表其父节点区间的左右两个子区间。这种结构使得线段树可以高效地处理各种与区间相关的操作，如区间查询、区间更新等。</p>
<p>与树状数组相比，线段树不依赖于2的次幂来划分区间，因此它更加灵活，可以处理任意长度的区间，而不仅仅是长度为2的幂的区间。这种特性让线段树在处理更广泛的区间问题时更加通用和强大。</p>
<p>线段树的主要优势在于其能够支持以下操作：</p>
<ol>
<li><strong>单点查询</strong>：在对数时间内查询数组中特定位置的值。</li>
<li><strong>区间查询</strong>：在对数时间内查询数组中任意连续区间的累积信息，如区间和、区间最大值、区间最小值等。</li>
<li><strong>单点更新</strong>：在对数时间内更新数组中特定位置的值，并保持区间信息的一致性。</li>
<li><strong>区间更新</strong>：在对数时间内更新数组中一段连续区间的值，并保持所有相关区间的信息更新。</li>
</ol>
<p>线段树的构建和操作通常涉及递归思想，通过不断将问题分解为更小的子问题来解决。这种分而治之的方法不仅提高了处理效率，还使得线段树成为解决复杂区间问题的理想选择。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/18/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC7%E8%AE%B2/%E7%BA%BF%E6%AE%B5%E6%A0%91/" data-id="cm23pcg0w000p362zbad80bhw" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第15讲/分块" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/18/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC15%E8%AE%B2/%E5%88%86%E5%9D%97/" class="article-date">
  <time class="dt-published" datetime="2024-08-18T01:27:12.000Z" itemprop="datePublished">2024-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="分块算法的基本思想："><a href="#分块算法的基本思想：" class="headerlink" title="分块算法的基本思想："></a>分块算法的基本思想：</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240712125755089.png" alt="image-20240712125755089"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240712125808675.png" alt="image-20240712125808675"></p>
<p>分块算法将整个区间<strong>分成若干个长度相同的子区间</strong>，每个子区间的长度通常取为总区间长度的平方根$( \sqrt{N} )$​​​。这种思想被称为<strong>“大段维护，小段朴素”</strong>，意味着对于跨越多个子区间的操作，我们采用维护一个总和或增量值的方法；而对于完全位于单个子区间内的操作，则直接进行朴素的迭代处理。</p>
<h4 id="修改操作："><a href="#修改操作：" class="headerlink" title="修改操作："></a>修改操作：</h4><p>当需要对区间 [l, r] 进行修改时，可以将这个区间划分为连续的大段和两边的小段。小段使用朴素方法处理，而大段则使用懒标记（lazy propagation）来维护。</p>
<h4 id="查询操作："><a href="#查询操作：" class="headerlink" title="查询操作："></a>查询操作：</h4><p>查询操作与修改操作类似，也是将区间 [l, r] 分为连续的大段和两边的小段。小段使用朴素方法查询，大段则利用维护的总和或增量值来快速得到结果。</p>
<p><img src="https://pic4.zhimg.com/v2-1655c12e302625448e5c09c6349258d7_r.jpg" alt="img"></p>
<h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>分块算法的时间复杂度通常稳定在 $O(T\sqrt{N}) $​​，其中  T  是操作的数量，N  是区间的总长度。与树状数组或线段树相比，分块算法在时间复杂度上可能更高，但它的通用性更好，代码量也较少，因此在某些情况下是一个不错的选择。</p>
<p>分块原理比较简单，下面是代码模板</p>
<h3 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h3><h4 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h4><p>已知一个数列，你需要进行下面两种操作：</p>
<p>将某区间每一个数加上 k。<br>求出某区间每一个数的和。</p>
<h4 id="预处理："><a href="#预处理：" class="headerlink" title="预处理："></a>预处理：</h4><p>为了方便减少码量和没必要的错误，要进行预处理来找出某些信息。</p>
<p>首先对块编号，以及记录每个块的左右下表，其次找出每个数组它所在哪一块。最好标出每个块大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)</span><br><span class="line">&#123;   </span><br><span class="line">    l[i]=r[i<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">    <span class="comment">//l[i] = n / sq * (i - 1) + 1; // l[i]表示i号块包含元素的左端点</span></span><br><span class="line">    r[i] = n / sq * i; <span class="comment">// r[i]表示i号块包含元素的右端点</span></span><br><span class="line">&#125;</span><br><span class="line">r[sq]=n;<span class="comment">//由于n不一定能开根开出整数，会有误差，我们把最后一个大块第sq的右端点里为n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)</span><br><span class="line">    size[i] = r[i] - l[i] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = l[i]; j &lt;= r[i]; j++)&#123;</span><br><span class="line">        bel[j] = i; <span class="comment">// 将每个数组标记好它在哪块</span></span><br><span class="line">        sum[i]+=A[j];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="修改操作：-1"><a href="#修改操作：-1" class="headerlink" title="修改操作："></a>修改操作：</h4><p>当需要对区间 [l, r] 进行修改时，可以将这个区间划分为连续的大段和两边的小段。小段使用朴素方法处理，而大段则使用懒标记（lazy propagation）来维护。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   修改一个区间[x,y]。x和y大致分为两种情况：1.同属一个块 2.不在一个块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//特判x和y在一个块内，朴素加就行</span></span><br><span class="line"><span class="keyword">if</span> (bel[x] == bel[y])&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= y; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] += k;</span><br><span class="line">        sum[bel[i]] += k;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不在一个块，对两边零散的位置朴素加，然后对中间的打上懒标记</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= r[bel[x]]; i++)</span><br><span class="line">&#123;</span><br><span class="line">    A[i] += k;</span><br><span class="line">    sum[bel[i]] += k;<span class="comment">//每个大块也要加上k</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l[bel[y]]; i &lt;= y; i++)<span class="comment">//同上</span></span><br><span class="line">&#123;</span><br><span class="line">    A[i] += k;</span><br><span class="line">    sum[bel[i]] += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对中间的块打上懒标记</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = bel[x] + <span class="number">1</span>; i &lt; bel[y]; ++i)</span><br><span class="line">&#123; </span><br><span class="line">    lazy[i] += k;</span><br><span class="line">    sum[bel[i]]+=k*size[i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//lazy[i]=k,i所在块里面的每个元素都要给它加上k</span></span><br></pre></td></tr></table></figure>

<h4 id="查询操作：-1"><a href="#查询操作：-1" class="headerlink" title="查询操作："></a>查询操作：</h4><p>查询操作与修改操作类似，也是将区间 [l, r] 分为连续的大段和两边的小段。小段使用朴素方法查询，大段则利用维护的总和或增量值来快速得到结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*查询也是将x和y分为两类。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//同属一个块就暴力加上每个元素，记得还有懒标记</span></span><br><span class="line"><span class="keyword">if</span> (bel[x] == bel[y])&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= y; i++)</span><br><span class="line">        s += A[i] + lazy[bel[i]]; <span class="comment">// 注意要加上标记</span></span><br><span class="line"><span class="comment">//不是就先处理两边碎的，中间的直接加上大块。</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= r[bel[x]]; i++)</span><br><span class="line">    s += A[i] + lazy[bel[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l[bel[y]]; i &lt;= y; i++)</span><br><span class="line">    s += A[i] + lazy[bel[i]];</span><br><span class="line"><span class="comment">//处理整块</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = bel[x] + <span class="number">1</span>; i &lt; bel[y]; i++)</span><br><span class="line">    s += sum[i] + lazy[i] * size[i]; <span class="comment">// 注意标记要乘上块长</span></span><br><span class="line"><span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure>



<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>分块算法适用于处理涉及大量区间修改和查询的问题，尤其是在数据量较大且操作较为频繁时，分块算法能够提供较为高效的解决方案。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>分块是一种简单而有效的算法思想，通过将数据划分为多个子区间并采用不同的策略来处理区间操作，可以在很多情况下提供比朴素方法更好的性能。尽管它可能不如树状数组或线段树那样复杂度低，但它的通用性和简洁性使其成为一个实用的选择。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/18/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC15%E8%AE%B2/%E5%88%86%E5%9D%97/" data-id="cm23pcg0u0009362z2defg6p7" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第5讲/并查集最近公共祖先lca" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/15/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC5%E8%AE%B2/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88lca/" class="article-date">
  <time class="dt-published" datetime="2024-08-15T02:57:02.000Z" itemprop="datePublished">2024-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并查集简介"><a href="#并查集简介" class="headerlink" title="并查集简介"></a>并查集简介</h1><p>并查集是一种数据结构，用于处理一些不交集的合并及查询问题。它的核心思想是通过维护一个“父亲数组”来记录每个元素所属的集合的代表（祖宗节点）。下面是对并查集的通俗易懂的解释。</p>
<p>并查集是一种非常高效的数据结构，用于处理一些不相交集合的合并和查询问题。它特别适合解决动态连通性问题。</p>
<h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><p>在开始时，每个元素都是一个独立的集合，每个元素的“父亲”就是它自己。例如，如果有一个数组 <code>p</code>，那么 <code>p[5]</code> 的初始值是 <code>5</code>，<code>p[3]</code> 的初始值是 <code>3</code>。</p>
<h2 id="合并操作（M）"><a href="#合并操作（M）" class="headerlink" title="合并操作（M）"></a>合并操作（M）</h2><p>如果执行的是合并操作（通常表示为 ‘M’），那么就会将两个集合合并成一个。合并的过程是找到两个元素的祖宗节点，并将其中一个祖宗节点的“父亲”指向另一个祖宗节点。例如，如果 <code>p[3]</code> 和 <code>p[5]</code> 是两个独立的集合，合并它们就是将 <code>p[3]</code> 的“父亲”指向 <code>p[5]</code>，即 <code>p[3] = p[5] = 5</code>。这样，3的祖宗节点就变成了5，集合 <code>&#123;5, 3&#125;</code> 就形成了。</p>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>如果要将某个元素 <code>p[9]</code> 插入到集合 <code>&#123;3&#125;</code> 中，需要找到3的祖宗节点，然后将 <code>p[9]</code> 指向这个祖宗节点。这个过程可以通过 <code>find(3)</code> 来实现，因为 <code>find()</code> 函数用于查找元素的祖宗节点。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>以下是并查集的模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 定义多个集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i; <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b); <span class="comment">// 集合合并操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) &#123;</span><br><span class="line">                <span class="comment">// 如果祖宗节点一样，就输出yes</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个代码中，<code>find()</code> 函数还实现了路径压缩，这是一个优化技巧，可以减少查找操作的时间复杂度。</p>
<h1 id="最近公共祖先（LCA）模板-倍增"><a href="#最近公共祖先（LCA）模板-倍增" class="headerlink" title="最近公共祖先（LCA）模板(倍增)"></a>最近公共祖先（LCA）模板(倍增)</h1><img src="https://pic1.zhimg.com/v2-99457646a2f9b511f82dd244eb76ba2c_720w.png?source=d16d100b" alt="算法学习笔记(21): 最近公共祖先" style="zoom:50%;" />

<p>​	节点祖先的最低（即最深的）节点。这个概念对于理解和解决树相关的算法问题非常重要。</p>
<p>在处理树上点与点关系的问题时，例如计算树上两点之间的距离，一个重要的概念是最近公共祖先（Lowest Common Ancestor，LCA）。</p>
<h3 id="朴素的LCA查找方法"><a href="#朴素的LCA查找方法" class="headerlink" title="朴素的LCA查找方法"></a>朴素的LCA查找方法</h3><ol>
<li><strong>深度优先搜索（DFS）</strong>：首先，我们通过DFS为每个节点确定深度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> p)</span></span>&#123;<span class="comment">//用倍增的思想处理st表处理这个深度。</span></span><br><span class="line"> dep[a] = dep[p] + <span class="number">1</span>;</span><br><span class="line"> fa[a][<span class="number">0</span>] = p;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">     fa[a][i] = fa[fa[a][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> x : e[a])</span><br><span class="line">     <span class="keyword">if</span>(x != p) <span class="built_in">dfs</span>(x, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>调整深度</strong>：如果A点的深度比B点深，我们让B点向上移动，直到两个点的深度相等。</li>
<li><strong>向上查找</strong>：然后，A点和B点一起向上移动，直到它们相遇的点，这个点就是LCA。</li>
</ol>
<p>这种方法的时间复杂度是O(n)。</p>
<h3 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h3><p>为了提高效率，特别是当需要进行多次查询时，我们可以使用倍增算法，该算法使用空间换时间。</p>
<ol>
<li><p><strong>存储祖先</strong>：创建一个数组<code>fa[i][k]</code>，存储每个节点的2^k级祖先。</p>
</li>
<li><p><strong>DFS过程中动态规划</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fa[cur][<span class="number">0</span>] = fath;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Log2[dep[cur]]; ++i)</span><br><span class="line">    fa[cur][i] = fa[fa[cur][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调整深度</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dep[a] &lt; dep[b]) <span class="built_in">swap</span>(a, b); <span class="comment">//我们让a是深度大的那一个</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">//注意这边是从高位枚举到低位 这样二进制才能凑出一个数，举个例子比如9的二进制是多少 是先枚举8 我发现8小于9,那就9-8=1,然后发现4&gt;1不行一直找到1，但是从小到大枚举就不能枚举出9的二进制了大家可以试试</span></span><br><span class="line">    <span class="keyword">if</span>(dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];<span class="comment">//然后让a一直向上爬，</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查找LCA</strong>：当两个点的深度相等后，如果它们已经相遇，那么当前点就是LCA。如果没有相遇，继续向上查找直到找到共同祖先。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">       <span class="keyword">if</span>(fa[a][i] != fa[b][i])&#123;</span><br><span class="line">           a = fa[a][i];</span><br><span class="line">           b = fa[b][i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fa[a][<span class="number">0</span>];<span class="comment">//直接返回最近公共祖先</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int get(int a,int b)&#123;</span><br><span class="line">   int ans=0;</span><br><span class="line">   for(int i=19;i&gt;=0;i--)&#123;</span><br><span class="line">      if(dep[fa[a][i]]&gt;=dep[b])&#123;</span><br><span class="line">           ans+=num[a][i];</span><br><span class="line">           a=fa[a][i];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return ans;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;get(a,lac(a,b))+get(b,lca(a,b));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="树上两点的距离"><a href="#树上两点的距离" class="headerlink" title="树上两点的距离"></a>树上两点的距离</h3><p>树上两点u和v的距离可以通过公式 <code>dis_&#123;u,v&#125; = dep_u + dep_v - 2 * dep_&#123;LCA(u,v)&#125;</code> 计算得出。这种方法提供了O(nlogn)的预处理时间和O(logn)的查询时间，空间复杂度为O(nlogn)。</p>
<p>如果树是加权的，可以通过记录每个点到根的距离，并使用类似的公式来计算两点之间的距离。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵有根多叉树，任务是找出指定两个节点的最近公共祖先。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><ul>
<li>第一行包含三个正整数 <code>N</code>, <code>M</code>, <code>S</code>，分别表示：<ul>
<li>树的节点个数 <code>N</code></li>
<li>查询的个数 <code>M</code></li>
<li>树根节点的序号 <code>S</code></li>
</ul>
</li>
<li>接下来 <code>N-1</code> 行，每行包含两个正整数 <code>x</code>, <code>y</code>，表示节点 <code>x</code> 和 <code>y</code> 之间存在一条直接连接的边（数据保证可以构成树）。</li>
<li>接下来 <code>M</code> 行，每行包含两个正整数 <code>a</code>, <code>b</code>，表示查询节点 <code>a</code> 和 <code>b</code> 的最近公共祖先。</li>
</ul>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含 <code>M</code> 行，每行包含一个正整数，依次为每一个查询的结果。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5 5 4</span><br><span class="line">3 1</span><br><span class="line">2 4</span><br><span class="line">5 1</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">3 2</span><br><span class="line">3 5</span><br><span class="line">1 2</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>

<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul>
<li>对于 30% 的数据，<code>N≤10</code>，<code>M≤10</code>。</li>
<li>对于 70% 的数据，<code>N≤10000</code>，<code>M≤10000</code>。</li>
<li>对于 100% 的数据，<code>1≤N,M≤500000</code>，<code>1≤x,y,a,b≤N</code>。不保证 <code>a≠b</code>。</li>
</ul>
<h2 id="算法1：倍增算法"><a href="#算法1：倍增算法" class="headerlink" title="算法1：倍增算法"></a>算法1：倍增算法</h2><p>时间复杂度 <code>O((n+m)logn)</code></p>
<h3 id="C-代码示例"><a href="#C-代码示例" class="headerlink" title="C++ 代码示例"></a>C++ 代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">20</span>], dep[N];  <span class="comment">//f[i][j]; 从i点向上跳2的j次方的点</span></span><br><span class="line"><span class="type">int</span> num[N][<span class="number">20</span>] 从i点向上跳<span class="number">2</span>的j次方的点与i号点的距离</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> p)</span></span>&#123;<span class="comment">//p是a节点的父节点</span></span><br><span class="line">    dep[a] = dep[p] + <span class="number">1</span>;<span class="comment">//深度·</span></span><br><span class="line">    fa[a][<span class="number">0</span>] = p;</span><br><span class="line">    num[a][<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++)<span class="comment">//通过递推 来求出st数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        fa[a][i] = fa[fa[a][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        num[a][i]=num[a][i<span class="number">-1</span>]+num[fa[a][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : e[a])<span class="comment">//遍历 vector</span></span><br><span class="line">        <span class="keyword">if</span>(x != p) <span class="built_in">dfs</span>(x, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[a] &lt; dep[b]) <span class="built_in">swap</span>(a, b);<span class="comment">//先保证让a深度大于等于b的深度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">//如果a点的深度不等于b点的深度 就让a点向上跳            </span></span><br><span class="line">        <span class="keyword">if</span>(dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">      <span class="comment">//  i==2 17-4=13  i==1n 13-2=11</span></span><br><span class="line">        <span class="comment">//a的深度 17 b点的深度是 11</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == b) <span class="keyword">return</span> a;<span class="comment">//a点b点一样 随便返回一个都是最近公共祖先</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[a][i] != fa[b][i])&#123;</span><br><span class="line">            a = fa[a][i];</span><br><span class="line">            b = fa[b][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];<span class="comment">//直接返回最近公共祖先</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>); cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">while</span>(--n)&#123;</span><br><span class="line">        <span class="type">int</span> a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b); e[b].<span class="built_in">push_back</span>(a);<span class="comment">//邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">lca</span>(a, b) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<pre><code>
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/15/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC5%E8%AE%B2/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88lca/" data-id="cm23pcg0v000l362zfjco5tsy" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第12讲/最小生成树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/13/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC12%E8%AE%B2/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2024-08-13T06:37:04.000Z" itemprop="datePublished">2024-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>给定一张边带有权重的无向图G &#x3D; (V, E) ，其中 |V| &#x3D; n 是顶点的数量，|E| &#x3D; m 是边的数量。由集合 V 中所有的 \n 个顶点和集合 E 中的 n-1 条边构成的无向连通子图被称为 G 的一棵生成树。如果这棵生成树的边权值之和是所有可能的生成树中最小的，那么它被称为无向图 G 的<strong>最小生成树（Minimum Spanning Tree，简称 MST）</strong>。</p>
<p><strong>定理：任意一棵最小生成树必然包含无向图中权值最小的边。</strong></p>
<p>证明：<br>我们使用反证法来证明这个定理。假设存在一棵最小生成树，它不包含权值最小的边。设 e &#x3D; (x, y, z)  是无向图中权值最小的边，其中  z  是  e 的权值。</p>
<p>如果将边  e 添加到最小生成树中，它会与树中从顶点 x  到顶点 y 的路径形成一个环。在这个环上，由于 e 是权值最小的边，所以环上其他边的权值都大于 z。</p>
<p>现在，如果我们用边 e 替换环上的任何一条权值大于  z 的边，我们会得到一个新的树，这个新树的总权值会比原来的最小生成树更小，因为它减少了至少  z 的权值。这与我们的假设矛盾，因为我们假设的最小生成树应该是权值最小的。</p>
<p>因此，我们的假设不成立，任意一棵最小生成树必然包含权值最小的边。这就证明了定理。</p>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>Kruskal算法是一种用于寻找无向图的最小生成树（MST）的算法。这个算法基于这样的原理：最小生成树一定包含图中权值最小的边，并且最小生成树是逐步构建的，每一步都添加一条边，这条边连接的是当前生成森林中的两棵树。</p>
<p>以下是对Kruskal算法的重新阐述：</p>
<ol>
<li><p><strong>初始化并查集</strong>：开始时，每个顶点都被视为一个独立的集合，即每个顶点都是它自己的树。</p>
</li>
<li><p><strong>排序边</strong>：将图中所有边按照它们的权值从小到大排序。</p>
</li>
<li><p><strong>扫描边</strong>：依次考虑每条边，对于每条边 ((x, y, z))，其中 (x) 和 (y) 是边的两个端点，(z) 是边的权值。</p>
</li>
<li><p><strong>检查连通性</strong>：如果 (x) 和 (y) 已经在同一个集合中，意味着它们已经通过之前的边连接在同一棵树中，因此忽略这条边。</p>
</li>
<li><p><strong>合并集合</strong>：如果 (x) 和 (y) 不在同一个集合中，将它们合并到同一个集合中，这意味着将它们连接在同一棵树上，并将边 (z) 的权值累加到最小生成树的总权值中。</p>
</li>
<li><p><strong>构建MST</strong>：重复步骤3到5，直到所有顶点都被包含在同一个集合中，即生成树已经包含所有顶点。</p>
</li>
<li><p><strong>算法结束</strong>：此时，所有被处理过的边构成了图的最小生成树。</p>
</li>
</ol>
<p>Kruskal算法的时间复杂度主要由边的排序和使用并查集进行合并操作决定。如果使用高效的排序算法和并查集，算法的时间复杂度可以达到 (O(m \log m))，其中 (m) 是图中边的数量。这是因为排序操作 (O(m \log m)) 和每次合并操作 (O(\log m))（因为并查集的路径压缩和按秩合并优化）的总和。</p>
<h4 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210000</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//并查集合并函数</span></span><br><span class="line">    <span class="keyword">if</span>(x!=p[x])p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="comment">//定义结构体</span></span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;n1) <span class="type">const</span>&#123;<span class="comment">//重载&lt;，让sort排序从小到大排</span></span><br><span class="line">        <span class="keyword">return</span> c&lt;n<span class="number">1.</span>c;<span class="comment">//以权值排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">//快读</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;e[i].a&gt;&gt;e[i].b&gt;&gt;e[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m);<span class="comment">//对边排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    p[i]=i;<span class="comment">//将所有的点都放到自己的集合里</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;<span class="comment">//最小生成树的权值和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a=e[i].a,b=e[i].b,c=e[i].c;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(a)!=<span class="built_in">find</span>(b))&#123;</span><br><span class="line">          p[<span class="built_in">find</span>(a)]=p[b];</span><br><span class="line">          res+=e[i].c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.acwing.com/media/article/image/2022/03/24/55289_97bd668aab-1.gif" alt="1.gif"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2022/03/24/55289_a697bc69ab-3.gif" alt="3.gif"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2022/03/24/55289_beee9e38ab-4.gif" alt="4.gif"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2022/03/24/55289_c637cb18ab-5.gif" alt="5.gif"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2022/03/24/55289_cafcd7bbab-6.gif" alt="6.gif"></p>
<p><img src="https://cdn.acwing.com/media/article/image/2022/03/24/55289_db160ef0ab-8.gif" alt="8.gif"></p>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>Prim算法是一种用于寻找图的最小生成树的算法，它与Dijkstra算法有相似之处，但目标不同。</p>
<ol>
<li><p><strong>算法初始化</strong>：Prim算法从图中的某个节点开始，通常选择编号为1的节点，并将其作为最小生成树的一部分。</p>
</li>
<li><p><strong>维护集合</strong>：在算法的每一步，维护两个节点集合，集合T包含已经确定属于最小生成树的节点，而集合S包含尚未确定的节点。</p>
</li>
<li><p><strong>选择最小边</strong>：算法寻找权值最小的边，这条边的两个端点分别属于集合S和T。</p>
</li>
<li><p><strong>更新集合</strong>：找到这样的最小边后，将端点x从集合S移动到集合T，并将其权值累加到最小生成树的总权值中。</p>
</li>
<li><p><strong>维护数组d</strong>：数组d用于记录每个节点x与集合T中节点之间权值最小的边的权值。如果x属于T，则d[x]记录的是x加入T时选出的最小边的权值。</p>
</li>
<li><p><strong>更新过程</strong>：算法可以类比Dijkstra算法，使用一个数组来标记节点是否已经属于T。每次从未标记的节点中选择d值最小的节点，将其标记为新加入T的节点，并更新其所有出边，即扫描与该节点相连的节点，如果通过这条边可以找到更小的到T的权值，则更新d值。</p>
</li>
<li><p><strong>算法结束</strong>：当所有节点都被加入到集合T时，算法结束。此时，最小生成树的权值总和可以通过计算所有d[x]的和得到。</p>
</li>
<li><p><strong>时间复杂度</strong>：Prim算法的时间复杂度为O(n^2)，但通过使用优先队列（如二叉堆）可以优化到O(m log n)，其中n是节点数，m是边数。</p>
</li>
<li><p><strong>适用场景</strong>：尽管Prim算法可以通过优化提高效率，但在处理稀疏图时，Kruskal算法通常更为方便。因此，Prim算法更适用于稠密图，尤其是完全图的最小生成树求解。</p>
</li>
</ol>
<p>简而言之，Prim算法通过逐步构建最小生成树，并通过维护两个节点集合和数组d来有效选择权值最小的边，最终得到最小生成树的总权值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N],dt[N];<span class="comment">//存储各个节点到生成树的距离</span></span><br><span class="line"><span class="type">int</span> st[N];<span class="comment">//节点是否被加入到生成树中</span></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//n 个节点，m 条边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dt,<span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dt));<span class="comment">//初始化距离数组为无限大</span></span><br><span class="line">    <span class="type">int</span> res= <span class="number">0</span>;</span><br><span class="line">    dt[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//先把第一个点放入集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)<span class="comment">//每次循环选出一个点加入到生成树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//每个节点一次判断</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (x == <span class="number">0</span> || dt[j] &lt; dt[x]))<span class="comment">//如果没有在树中，且到树的距离最短，则选择该点</span></span><br><span class="line">                x = j;</span><br><span class="line">        st[x] = <span class="number">1</span>;<span class="comment">//这个点选上，打上标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; y++)<span class="comment">//更新集合的距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dt[y] &gt; g[x][y] &amp;&amp; !st[y])<span class="comment">//从 t 到节点 i 的距离小于原来距离，则更新。</span></span><br><span class="line">                dt[y] = g[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res+=dt[i];<span class="comment">//加上每条边得到最小生成树的权</span></span><br><span class="line">        <span class="keyword">if</span>(dt[i]&gt;<span class="number">10000000</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));<span class="comment">//点距离初始化为无限大</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b],w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">prim</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/13/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC12%E8%AE%B2/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" data-id="cm23pcg0s0002362zbxx11atp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第9讲/单调队列dp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/27/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC9%E8%AE%B2/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97dp/" class="article-date">
  <time class="dt-published" datetime="2024-07-26T18:03:12.000Z" itemprop="datePublished">2024-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="单调队列定义："><a href="#单调队列定义：" class="headerlink" title="单调队列定义："></a>单调队列定义：</h4><p>其实单调队列就是一种队列内的元素有单调性（单调递增或者单调递减）的队列，答案（也就是最优解）就存在队首，而队尾则是最后进队的元素。因为其单调性所以经常会被用来维护区间最值 或者 降低DP的维数已达到降维来减少空间及时间的目的。</p>
<p>单调队列可以有两个操作：<br>1、插入一个新的元素，该元素从队尾开始向队首进行搜索，找到合适的位置插入之，如果该位置原本有元素，则替换它。<br>2、在过程中从队首删除不符合当前要求的元素。<br>单调队列实现起来可简单，可复杂。简单的一个数组，一个head，一个tail指针就搞定。复杂的用双向链表实现。</p>
<p>单调队列的一般应用：<br>1.维护区间最值 　　　　<br>2.优化DP</p>
<h4 id="第一种：不需要设置哨兵"><a href="#第一种：不需要设置哨兵" class="headerlink" title="第一种：不需要设置哨兵"></a>第一种：不需要设置哨兵</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hh = 0,tt = -1;</span><br><span class="line">for(int i = 0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])hh++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二种：需要设置哨兵-一般用于前缀和的单调队列和单调队列优化DP"><a href="#第二种：需要设置哨兵-一般用于前缀和的单调队列和单调队列优化DP" class="headerlink" title="第二种：需要设置哨兵,一般用于前缀和的单调队列和单调队列优化DP"></a>第二种：需要设置哨兵,一般用于前缀和的单调队列和单调队列优化DP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hh = 0,tt = 0;//哨兵不初始化的话是0</span><br><span class="line">for(int i = 1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(hh &lt;= tt &amp;&amp; i - k &gt; q[hh])hh++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="最大子序和问题概述"><a href="#最大子序和问题概述" class="headerlink" title="最大子序和问题概述"></a>最大子序和问题概述</h5><p>给定一个长度为<strong>n</strong>的序列<strong>a</strong>，要求找出其中元素总和最大的且长度不超过<strong>m</strong>的连续子区间。</p>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>为了解决这个问题，我们可以使用前缀和来优化，然后枚举子区间的右端点。状态表示为<code>fi</code>，表示以<code>i</code>为右端点，长度不超过<strong>m</strong>连续子区间的总和最大值。</p>
<h5 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h5><ul>
<li><strong>集合</strong> <code>fi</code>：以<code>i</code>为右端点，长度不超过<strong>m</strong>的连续子区间。</li>
<li><strong>属性</strong> <code>fi</code>：区间的总和最大值<code>Max</code>。</li>
</ul>
<h5 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h5><p>状态转移方程为：<br>$f[i] &#x3D; \max_{1 \leq i-j \leq m} (s[i] - s[j]) $<br>其中，<code>s[i]</code>是前缀和，<code>j</code>的范围是<code>i-m</code>到<code>i-1</code>。</p>
<h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>为了从前向后维护一个长度不超过<strong>m</strong>的区间的最小值，我们可以使用单调队列（单调递增）。队列的头部将始终维护着当前窗口的最小前缀和。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是使用单调队列优化DP的最大子序和问题的C++代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL s[N], que[N]; <span class="comment">// que[] 用作单调队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]), s[i] += s[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    LL res = LLONG_MIN; <span class="comment">// 初始化结果为最小长整型</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>; <span class="comment">// hh 为队头，tt 为队尾</span></span><br><span class="line">    que[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 初始化队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 维护单调队列，移除队头直到队列长度不超过m</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; i - que[hh] &gt; m) hh++;</span><br><span class="line">        <span class="comment">// 更新结果，计算以当前i为结尾的最大子序和</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, s[i] - s[que[hh]]);</span><br><span class="line">        <span class="comment">// 维护单调队列，移除队尾直到队列元素满足单调性</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; s[que[tt]] &gt;= s[i]) tt--;</span><br><span class="line">        <span class="comment">// 将当前索引i加入到队列中</span></span><br><span class="line">        que[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="经典滑动窗口问题"><a href="#经典滑动窗口问题" class="headerlink" title="经典滑动窗口问题"></a>经典滑动窗口问题</h4><p>题目描述</p>
<p>有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p>
<p>例如，对于序列 $[1,3,-1,-3,5,3,6,7]$ 以及 $k &#x3D; 3$，有如下过程：</p>
<p>$$<br>\def\arraystretch{1.2}<br>\begin{array}{|c|c|c|}\hline<br>\textsf{窗口位置} &amp; \textsf{最小值} &amp; \textsf{最大值} \ \hline<br>\verb![1   3  -1] -3   5   3   6   7 ! &amp; -1 &amp; 3 \ \hline<br>\verb! 1  [3  -1  -3]  5   3   6   7 ! &amp; -3 &amp; 3 \ \hline<br>\verb! 1   3 [-1  -3   5]  3   6   7 ! &amp; -3 &amp; 5 \ \hline<br>\verb! 1   3  -1 [-3   5   3]  6   7 ! &amp; -3 &amp; 5 \ \hline<br>\verb! 1   3  -1  -3  [5   3   6]  7 ! &amp; 3 &amp; 6 \ \hline<br>\verb! 1   3  -1  -3   5  [3   6   7]! &amp; 3 &amp; 7 \ \hline<br>\end{array}<br>$$<br>【数据范围】<br>对于 $50%$ 的数据，$1 \le n \le 10^5$；<br>对于 $100%$ 的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。【数据范围】<br>对于 $50%$ 的数据，$1 \le n \le 10^5$；<br>对于 $100%$ 的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。</p>
<p><strong>输入格式</strong></p>
<p>输入一共有两行，第一行有两个正整数 $n,k$。<br>第二行 $n$ 个整数，表示序列 $a$</p>
<p><strong>输出格式</strong></p>
<p>输出共两行，第一行为每次窗口滑动的最小值<br>第二行为每次窗口滑动的最大值</p>
<p><strong>样例</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/27/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC9%E8%AE%B2/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97dp/" data-id="cm23pcg0w000t362z8khxhlpp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第8讲/最长上升子序列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/27/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2024-07-26T18:00:32.000Z" itemprop="datePublished">2024-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最长上升子序列（Longest Increasing Subsequence, LIS）问题是指在一个给定序列中找到一个最长的子序列，这个子序列中的元素是严格递增的。以下是对LIS问题的重新表述和两种解法的解释：</p>
<h3 id="LIS问题概述"><a href="#LIS问题概述" class="headerlink" title="LIS问题概述"></a>LIS问题概述</h3><ul>
<li><strong>问题定义</strong>：给定一个序列nums，找到一个最长的严格递增子序列。</li>
<li><strong>示例</strong>：序列[1, 3, 5, 4, 7]的最长上升子序列是[1, 3, 5, 7]，长度为4。</li>
</ul>
<h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><ul>
<li><strong>状态定义</strong>：<code>dp[i]</code>表示以第i个元素结尾的最长上升子序列的长度。</li>
<li><strong>状态转移方程</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    <span class="keyword">if</span> (nums[j] &lt; nums[i])</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li><strong>算法逻辑</strong>：<ol>
<li>初始化<code>dp</code>数组，每个元素为1，因为每个元素自己可以看作长度为1的上升子序列。</li>
<li>通过嵌套循环遍历所有元素对，如果<code>nums[j] &lt; nums[i]</code>，则<code>nums[i]</code>可以接在<code>nums[j]</code>后面形成一个更长的上升子序列。</li>
<li><code>dp</code>数组中的最大值即为所求的最长上升子序列的长度。</li>
</ol>
</li>
</ul>
<h3 id="二分查找优化解法"><a href="#二分查找优化解法" class="headerlink" title="二分查找优化解法"></a>二分查找优化解法</h3><ul>
<li><strong>优化思路</strong>：使用二分查找优化查找和替换操作，从而降低时间复杂度。</li>
<li><strong>算法逻辑</strong>：<ol>
<li>维护一个当前最长上升子序列<code>dp</code>。</li>
<li>对于每个元素<code>nums[i]</code>，使用<code>lower_bound</code>在<code>dp</code>中找到第一个大于或等于<code>nums[i]</code>的位置<code>pos</code>。</li>
<li>如果<code>pos</code>等于<code>dp</code>的大小，则将<code>nums[i]</code>添加到<code>dp</code>的末尾；否则，用<code>nums[i]</code>替换<code>dp[pos]</code>。</li>
<li>最终，<code>dp</code>的大小即为最长上升子序列的长度。</li>
</ol>
</li>
</ul>
<h3 id="C-代码示例"><a href="#C-代码示例" class="headerlink" title="C++代码示例"></a>C++代码示例</h3><p>以下是使用动态规划和二分查找优化的C++代码示例：</p>
<h4 id="动态规划解法-1"><a href="#动态规划解法-1" class="headerlink" title="动态规划解法"></a>动态规划解法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二分查找优化解法-1"><a href="#二分查找优化解法-1" class="headerlink" title="二分查找优化解法"></a>二分查找优化解法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), nums[i]) - dp.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span> (pos == dp.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            dp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[pos] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最长上升子序列问题是动态规划领域的经典问题。通过动态规划可以以O(n^2)的时间复杂度求解，而使用二分查找可以进一步将时间复杂度降低到O(nlogn)。二分查找优化版本的空间复杂度为O(n)，使其在处理大规模数据时更为高效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/27/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/" data-id="cm23pcg0w000r362z9p2aebpv" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E8%AE%B2/%E8%B4%AA%E5%BF%83%E8%A7%A3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC6%E8%AE%B2/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC7%E8%AE%B2/%E7%BA%BF%E6%AE%B5%E6%A0%91/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
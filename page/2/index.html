<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-课编程/第5讲/倍增" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/17/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC5%E8%AE%B2/%E5%80%8D%E5%A2%9E/" class="article-date">
  <time class="dt-published" datetime="2024-07-17T01:06:14.000Z" itemprop="datePublished">2024-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="RMQ算法概述"><a href="#RMQ算法概述" class="headerlink" title="RMQ算法概述"></a>RMQ算法概述</h3><p>RMQ是解决区间最值问题的一种算法，它可以高效地处理多个区间最值查询。在朴素算法中，对于每个查询，我们可能需要遍历整个区间以找到最值，这在有大量查询的情况下效率很低。RMQ算法通过预处理数据，将查询时间复杂度降低到O(1)。</p>
<h3 id="ST算法实现"><a href="#ST算法实现" class="headerlink" title="ST算法实现"></a>ST算法实现</h3><p>ST算法是一种预处理技术，它使用一个二维的动态规划（DP）数组来存储区间的最值信息。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化DP数组，其中<code>dp[i][0]</code>存储的是单个元素（即索引i）的值，直接从输入的Matrix数组中获取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    dp[i][<span class="number">0</span>] = Matrix[i];</span><br></pre></td></tr></table></figure>

<h4 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h4><p>通过递推的方式，逐步增加区间长度，计算更长区间的最值。递推公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i][j-1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);</span><br></pre></td></tr></table></figure>

<p>这里的<code>j</code>表示区间长度，<code>i</code>表示区间的起始索引。通过合并两个较小的区间来计算一个更大的区间的最值。</p>
<h4 id="循环变量解释"><a href="#循环变量解释" class="headerlink" title="循环变量解释"></a>循环变量解释</h4><ul>
<li><code>j</code>：区间长度的指数部分，即从第<code>i</code>个数开始的<code>2^j</code>个数。</li>
<li><code>i</code>：区间的起始索引，循环更新每个区间的最值。</li>
</ul>
<h4 id="细节思考"><a href="#细节思考" class="headerlink" title="细节思考"></a>细节思考</h4><p>由于DP数组中的区间都是基于2的幂次长度，对于非2的幂次的区间，可以通过取两个有重叠部分的区间的最大值来得到结果。</p>
<h4 id="结果证明"><a href="#结果证明" class="headerlink" title="结果证明"></a>结果证明</h4><p>对于区间<code>[a, b]</code>，可以通过计算<code>dp[a][k]</code>和<code>dp[b - (1 &lt;&lt; k) + 1][k]</code>来得到最值，其中<code>k = log2(b - a + 1)</code>。需要证明<code>b - (1 &lt;&lt; k) + 1 &lt;= a + (1 &lt;&lt; k) - 1</code>。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是ST算法的C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii  pair<span class="string">&lt;int, int&gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Matrix[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">200000</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; Matrix[i];</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = Matrix[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">log2</span>(b - a + <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(dp[a][k], dp[b - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RMQ算法通过预处理数据结构，将区间最值查询的时间复杂度从O(n)降低到O(1)，大大提高了处理大量查询的效率。ST算法是实现RMQ的一种有效方法，它利用动态规划和递推思想来构建一个可以快速查询的DP数组。通过适当的初始化和递推逻辑，可以快速响应区间最值的查询请求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/17/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC5%E8%AE%B2/%E5%80%8D%E5%A2%9E/" data-id="cm23pcg0v000k362z26srhz25" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第6讲/树上差分树形dp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/17/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC6%E8%AE%B2/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%E6%A0%91%E5%BD%A2dp/" class="article-date">
  <time class="dt-published" datetime="2024-07-17T01:06:04.000Z" itemprop="datePublished">2024-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="树上前缀和的概念"><a href="#树上前缀和的概念" class="headerlink" title="树上前缀和的概念"></a>树上前缀和的概念</h3><p>树上前缀和是一种在树上进行求和的方法，它可以分为两大类：</p>
<ol>
<li><strong>从底向上</strong>：这种方法中，某个节点的前缀和是指以该节点为根的子树上所有节点的权值（或者边的权值）的总和。</li>
<li><strong>自顶向下</strong>：这种方法中，从根节点到某个节点的路径上的前缀和是指从根节点到该节点的路径上所有节点（或者边）的权值总和。</li>
</ol>
<h4 id="从底向上的计算"><a href="#从底向上的计算" class="headerlink" title="从底向上的计算"></a>从底向上的计算</h4><p>在从底向上的方法中，如果给定的是节点权，计算两个节点x和y之间路径的和可以通过以下公式实现：</p>
<p>$$<br>\text{路径和} &#x3D; \text{sum}[x] + \text{sum}[y] - \text{sum}[LCA(x, y)] - \text{sum}[fa[x]]<br>$$</p>
<p>其中，<code>LCA(x, y)</code> 表示x和y的最近公共祖先，<code>fa[x]</code> 表示x的父节点。</p>
<p>如果给定的是边权，那么计算x和y之间路径的和的公式变为：</p>
<p>$$<br>\text{路径和} &#x3D; \text{sum}[x] + \text{sum}[y] - 2 \times \text{sum}[LCA(x, y)]<br>$$</p>
<h4 id="自顶向下的应用"><a href="#自顶向下的应用" class="headerlink" title="自顶向下的应用"></a>自顶向下的应用</h4><p>当然，关于树上前缀和的从底向上的部分：</p>
<p>从底向上的树上前缀和是指在树结构中，每个节点的前缀和代表了以该节点为根的子树中所有节点的权值（或者边权）的累加和。具体来说：</p>
<ol>
<li><p><strong>点权前缀和</strong>：在点权的情况下，每个节点的前缀和是其所有子节点的前缀和加上该节点本身的权值。这意味着，对于任意节点 ( i )，其前缀和可以通过对其所有子节点的前缀和进行累加，然后加上节点 ( i ) 的权值来得到。</p>
</li>
<li><p><strong>边权前缀和</strong>：在边权的情况下，前缀和是从根节点到该节点的路径上所有边的权值之和。这通常涉及到将边权分摊到路径上的各个节点上。</p>
</li>
</ol>
<p>在实现算法时，我们通常从树的叶子节点开始，通过深度优先搜索（DFS）向上逐层计算每个节点的前缀和。对于点权，这可以通过在递归过程中累加子节点的前缀和来实现。而对于边权，可以通过在递归过程中累加到当前节点的路径上所有边的权值来实现。</p>
<p>例如，如果我们考虑一个节点 ( i ) 及其子节点集合 ( \text{sons}(i) )，那么节点 ( i ) 的前缀和可以通过以下步骤计算：</p>
<ul>
<li><p>对于点权：$$\text{PrefixSum}[i] &#x3D; w[i] + \sum_{j \in \text{sons}(i)} \text{PrefixSum}[j] $$</p>
</li>
<li><p>对于边权：$$ \text{PrefixSum}[i] &#x3D; \sum_{\text{边从 } i \text{ 到 } j \in \text{sons}(i)} \text{权值} + \sum_{j \in \text{sons}(i)} \text{PrefixSum}[j] $$</p>
<p>这种方法允许我们从叶子节点开始，逐步向上计算直到根节点，从而得到整个树的前缀和信息。</p>
</li>
</ul>
<h5 id="自底向上的点权前缀和代码示例："><a href="#自底向上的点权前缀和代码示例：" class="headerlink" title="自底向上的点权前缀和代码示例："></a>自底向上的点权前缀和代码示例：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum[N]; <span class="comment">// 点权前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123; <span class="comment">// 递归函数，u是当前节点，fa是当前节点的父节点</span></span><br><span class="line">    sum[u] = w[u]; <span class="comment">// 初始化当前节点的前缀和为其自身的权值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123; <span class="comment">// 遍历当前节点的所有子节点</span></span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (j != fa) &#123; <span class="comment">// 如果子节点j不是父节点</span></span><br><span class="line">            <span class="built_in">dfs</span>(j, u); <span class="comment">// 递归计算子节点j的前缀和</span></span><br><span class="line">            sum[u] += sum[j]; <span class="comment">// 将子节点j的前缀和累加到当前节点的前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自底向上的边权前缀和代码示例："><a href="#自底向上的边权前缀和代码示例：" class="headerlink" title="自底向上的边权前缀和代码示例："></a>自底向上的边权前缀和代码示例：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum[N]; <span class="comment">// 边权前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sum[u] = <span class="number">0</span>; <span class="comment">// 初始化当前节点的前缀和为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123; <span class="comment">// 遍历当前节点的所有子节点</span></span><br><span class="line">        <span class="type">int</span> j = e[i^<span class="number">1</span>]; <span class="comment">// 由于是无向图，边权需要分配到两个节点上</span></span><br><span class="line">        <span class="keyword">if</span> (j != fa) &#123;</span><br><span class="line">            sum[j] += sum[u] + w[i]; <span class="comment">// 将当前节点的前缀和加上边的权值，累加到子节点的前缀和</span></span><br><span class="line">            <span class="built_in">dfs</span>(j, u); <span class="comment">// 递归计算子节点j的前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际应用中，还需要定义其他辅助变量和函数，例如邻接表的<code>h[N]</code>和<code>e[M]</code>，以及边权<code>w[M]</code>等。此外，<code>N</code>是节点的数量，<code>M</code>是边的数量，<code>w</code>是边权数组，<code>h</code>是邻接表的头指针数组，<code>e</code>是邻接表的边数组，<code>ne</code>是邻接表的下一条边指针数组。</p>
<h3 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a>树上差分</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240715130951450.png" alt="image-20240715130951450"></p>
<p>树上差分是处理树结构数据时的一种优化技巧，它允许我们对树中的节点或边权进行动态更新，同时能够快速计算这些更新对任意两点间路径的影响。树上差分主要有两种情况：点权差分和边权差分。</p>
<h4 id="点权差分"><a href="#点权差分" class="headerlink" title="点权差分"></a>点权差分</h4><p>在点权差分中，我们对树中某些节点的权值进行增减操作。这些操作会通过树的结构向上传播，直到影响到树的所有相关部分。例如，如果我们想增加节点 (x) 和 (y) 的权值，并减少它们最近公共祖先 (LCA(x, y)) 及其父节点的权值，差分操作可以表示为：<br>[ d[x]++, d[y]++, d[LCA(x, y)]–, d[fa[LCA(x, y)]]–; ]<br>这里，(d) 是差分数组，(fa) 表示节点的父节点。</p>
<h4 id="边权差分"><a href="#边权差分" class="headerlink" title="边权差分"></a>边权差分</h4><p>边权差分与点权差分类似，但操作的对象是树的边。例如，如果我们想增加边 (x) 到 (y) 的权值，差分操作可以表示为：<br>[ d[x]++, d[y]++, d[LCA(x, y)]-&#x3D;2; ]<br>这表示边 (x) 到 (y) 的权值增加，而它们最近公共祖先的权值减少两倍。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>实现树上差分通常包括以下步骤：</p>
<ol>
<li><strong>初始化</strong>：为每个节点或边初始化一个差分数组。</li>
<li><strong>更新操作</strong>：对需要更新的节点或边进行操作，同时修改差分数组。</li>
<li><strong>传播</strong>：根据树的结构，将更新传播到受影响的节点或边。</li>
<li><strong>查询</strong>：通过累加路径上的差分值，快速计算两点间的路径和。</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>以下是点权差分的一个简单代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        d[x] += delta;</span><br><span class="line">        x += x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret += d[x];</span><br><span class="line">        x -= x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码展示了如何使用差分数组来更新节点的权值并查询某个节点的累积权值。</p>
<p>请注意，树上差分的具体实现可能会根据问题的具体需求和树的结构有所不同。在实际应用中，可能还需要结合其他数据结构和算法，如最近公共祖先（LCA）查询等。</p>
<h3 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h3><p>假设我们有一棵包含N个节点的树（这通常是一棵无根树，意味着有N-1条无向边），我们可以自由选择任何一个节点作为根节点，这样就能够确定每个节点的深度以及每个子树的根节点。在树状结构上设计动态规划算法时，我们通常按照节点的深度从下到上（即从子树的规模小到大）的顺序来进行动态规划的各个阶段。在动态规划的状态定义中，第一维通常指的是节点的编号，这代表了以该节点为根的子树。大多数情况下，我们会使用递归的方式来实现树形动态规划。对于树中的每一个节点x，我们会先递归地对它的所有子节点进行动态规划，在递归返回时，从子节点向节点x进行状态的转移。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240526152624106.png" alt="image-20240526152624106"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240526152807420.png" alt="image-20240526152807420"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240526152701936.png" alt="image-20240526152701936"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">7</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">6 4</span><br><span class="line">7 4</span><br><span class="line">4 5</span><br><span class="line">3 5</span><br><span class="line">输出：</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>题解：</p>
<p>当然，这句话可以重新表述如下：</p>
<p>假设每个人可以选择参加或不参加舞会，即存在两种可能的状态。我们定义一个二维数组 <code>dp</code>，其中 <code>dp[0][i]</code> 表示第 <code>i</code> 个人选择不参加舞会时，他的下属能够获得的最大快乐值；而 <code>dp[1][i]</code> 表示第 <code>i</code> 个人选择参加舞会时，他的下属能够获得的最大快乐值。<br>$$<br>dp[0][i] &#x3D; \sum_{u \in \text{sons}} \max(dp[1][u], dp[0][u])<br>$$<br>   当前节点不选，那么子节点随意。<br>$$<br>dp[1][i] &#x3D; \sum_{u \in \text{sons}} dp[0][u] + happy[i]<br>$$<br>   当前节点选，子节点不能选。</p>
<p>在进行树形动态规划时，每个节点的状态（即是否参加舞会）需要在它的所有子节点的状态更新完成后才能确定。为了实现这一点，可以采用一种类似拓扑排序的方法：</p>
<ol>
<li><p><strong>记录父子关系</strong>：只记录每个子节点的父亲节点，而不是构建整个树的图结构。这样可以简化问题，避免复杂的图构建过程。</p>
</li>
<li><p><strong>从叶子节点开始</strong>：由于叶子节点（即没有子节点的节点）没有下属，它们的状态可以首先被确定。从这些入度为0的节点开始，逐步向上更新状态。</p>
</li>
<li><p><strong>状态更新</strong>：在更新每个子节点的状态时，同时更新其父节点的状态。具体来说，如果子节点选择不参加舞会（<code>dp[0][i]</code>），则父节点在更新时需要加上子节点的快乐值（<code>happy[i]</code>）；如果子节点选择参加舞会（<code>dp[1][i]</code>），则父节点在更新时不需要加上这个值。</p>
</li>
<li><p><strong>避免重复计算</strong>：通过这种方式，当最终到达每个节点的父节点时，所有子节点的状态已经更新完毕，父节点的状态也就可以直接确定，从而避免了重复计算和构建整个图的复杂性。</p>
</li>
</ol>
<p>简而言之，这种方法通过记录父子关系并从叶子节点向上进行状态更新，可以在不构建完整图的情况下，有效地解决树形动态规划问题。</p>
<p>具体代码见下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> ll N=<span class="number">6e3</span><span class="number">+5</span>;</span><br><span class="line">ll n,r[N],u,v,num,head[N],dp[N][<span class="number">2</span>],root;</span><br><span class="line"><span class="type">bool</span> pd[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll to,next;</span><br><span class="line">&#125; edge[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll u,ll v)</span> </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    edge[num].to=v;</span><br><span class="line">    edge[num].next=head[u];</span><br><span class="line">    head[u]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u)</span> </span>&#123;</span><br><span class="line">    dp[u][<span class="number">1</span>]=r[u];</span><br><span class="line">    <span class="keyword">for</span> (ll i=head[u]; i&gt;<span class="number">0</span>; i=edge[i].next) &#123;</span><br><span class="line">        ll v=edge[i].to;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (ll i=<span class="number">1</span>; i&lt;=n; i++) cin&gt;&gt;r[i];</span><br><span class="line">    <span class="keyword">for</span> (ll i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        pd[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    root=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pd[root])    root++; </span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(dp[root][<span class="number">0</span>],dp[root][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/17/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC6%E8%AE%B2/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%E6%A0%91%E5%BD%A2dp/" data-id="cm23pcg0w000n362z2dbn3f7y" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第2讲/贪心二分前缀和差分" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/16/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E8%AE%B2/%E8%B4%AA%E5%BF%83%E4%BA%8C%E5%88%86%E5%89%8D%E7%BC%80%E5%92%8C%E5%B7%AE%E5%88%86/" class="article-date">
  <time class="dt-published" datetime="2024-07-15T17:50:54.000Z" itemprop="datePublished">2024-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h4 id="长话短说：找规律"><a href="#长话短说：找规律" class="headerlink" title="长话短说：找规律"></a>长话短说：找规律</h4><h5 id="基本思想-问题的某个初始解出发，采用逐步构造最优解的方法，通过局部解来得到全局最优解。每一个局部阶段，都做一个在当前“看上去”最优的决策，并期望通过每一次所做的局部最优选择产生出一个全局最优解。"><a href="#基本思想-问题的某个初始解出发，采用逐步构造最优解的方法，通过局部解来得到全局最优解。每一个局部阶段，都做一个在当前“看上去”最优的决策，并期望通过每一次所做的局部最优选择产生出一个全局最优解。" class="headerlink" title="基本思想:问题的某个初始解出发，采用逐步构造最优解的方法，通过局部解来得到全局最优解。每一个局部阶段，都做一个在当前“看上去”最优的决策，并期望通过每一次所做的局部最优选择产生出一个全局最优解。"></a>基本思想:问题的某个初始解出发，采用逐步构造最优解的方法，通过局部解来得到全局最优解。每一个局部阶段，都做一个在当前“看上去”最优的决策，并期望通过每一次所做的局部最优选择产生出一个全局最优解。</h5><p>贪心只是一种策略或方法，也可以说成是一个思路思想。而不是算法。</p>
<p>案例1–4763 删除数字</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240518112035593.png" alt="image-20240518112035593"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240518112113275.png" alt="image-20240518112113275"></p>
<p><strong>思路</strong></p>
<p>这道题是看怎么贪，怎么删除法。如果一直都删除数组里的最大数字是能让数字变小，但不是最优策略。举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">34319 1</span><br><span class="line">删除最大的数字 3231</span><br><span class="line">删除第二个数字 3319</span><br><span class="line">显然第二个是大的</span><br></pre></td></tr></table></figure>

<p>ok，为什么删除4要好，因为让这个高位变小，删除只是改变个位显然贡献较小<br>从高位删除的方法就是，从左右往右删去第一个比后一个大的数字比如234543212 删除5是最优的。</p>
<p>下文代码通过srting来模拟这个过程，因为string的erase方法可以能够减少冗余的码文。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="keyword">while</span> (k--)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="type">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s[i] &gt; s[i + <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                                s.<span class="built_in">erase</span>(i,<span class="number">1</span>);	</span><br><span class="line">                                f = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!f)        s.<span class="built_in">erase</span>(s.<span class="built_in">size</span>() - <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)        s.<span class="built_in">erase</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="string">&quot;&quot;</span>)        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="终极案例-—2881-接苹果"><a href="#终极案例-—2881-接苹果" class="headerlink" title="终极案例 —2881 接苹果"></a>终极案例 —2881 接苹果</h5><p><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_4a357b6b13-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158548454359.png" alt="企业微信截图_17158548454359.png"><br><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_626ea16a13-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158548846822.png" alt="企业微信截图_17158548846822.png"><br><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_662b315413-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158549023583.png" alt="企业微信截图_17158549023583.png"><br><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_6ada855f13-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158549181483.png" alt="企业微信截图_17158549181483.png"> </p>
<p>（题外话 可能与蚂蚁的那道题类似但写法截然不同）</p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>首先这道题是根据某个性质进行贪心。</p>
<p>第一步我们分析题目–如果奶牛能接到苹果恒等于t^1^-t$\geq$$|s^1-s|$ <strong>(批注：t^1^,s^1^是苹果的初始的时间和坐标，t,s是奶牛的，下文的恒等于都用&lt;&#x3D;&gt;代替。)</strong><br>我们将绝对值拆开，t^1^-t$\geq$$|s^1-s|$  &lt;&#x3D;&gt;   t^1^-t$\geq$max(s^1^-s,s-s^1^)   &lt;&#x3D;&gt;   </p>
<p>满足两个不等式   </p>
<h5 id="1-t-1-t-geq-s-1-s"><a href="#1-t-1-t-geq-s-1-s" class="headerlink" title="1.t^1^-t$\geq$s^1^-s"></a>1.t^1^-t$\geq$s^1^-s</h5><h5 id="2-t-1-t-geq-s-s-1"><a href="#2-t-1-t-geq-s-s-1" class="headerlink" title="2.t^1^-t$\geq$s-s^1^"></a>2.t^1^-t$\geq$s-s^1^</h5><p>继续化简&lt;&#x3D;&gt;</p>
<h5 id="1-t-1-s-1-geq-t-s"><a href="#1-t-1-s-1-geq-t-s" class="headerlink" title="1.t^1^-s^1^$\geq$t-s"></a>1.t^1^-s^1^$\geq$t-s</h5><h5 id="2-t-1-s-1-geq-t-s"><a href="#2-t-1-s-1-geq-t-s" class="headerlink" title="2.t^1^+s^1^$\geq$t+s"></a>2.t^1^+s^1^$\geq$t+s</h5><p>好，我们令 t-s&#x3D;x,t+s&#x3D;y。现在能看到性质了，<strong>如果某头牛能拿到某个苹果则x^1^$\geq$x且y^1^$\geq$​​y</strong>。</p>
<p><strong>则苹果被牛抓到的条件为(X^1^,Y^1^) $\in$[x,$\infty$)$\cap$[y,$\infty$)。</strong></p>
<p>好，得到这两个限制条件，可以通过对x或y任意一个排序来达到使其中一个必然满足，这边对y排序。</p>
<p>对y进行降序排序，如果y相同则对x进行降序排序。根据题目约束不可能存在两个相同的点，那么顺次枚举，如果是苹果就加入 <code>multiset</code>，如果是奶牛就 <code>lower_bound</code> 当前的 <code>multiset</code> 中最小的横坐标 ≥x 的点。不难发现总复杂度是 𝑂(𝑛log⁡𝑛) 的。</p>
<p>(晦涩难懂？那就换个图自己模拟一下就懂了)</p>
<p>晦涩点1，为什么不用管y？答：因为y是排好序的后面的必然能选前面但是x不是。</p>
<p>晦涩点2，为什么要lower_bound(x)？答：set里是按x排序的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span> &#123;<span class="type">int</span> q,x,y,n;&#125;op[N];</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(P a,P b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(P a,P b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x==b.x;</span><br><span class="line">&#125;</span><br><span class="line">multiset&lt;P&gt;apple;</span><br><span class="line">multiset&lt;P&gt;::iterator it;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.y==b.y?a.x&gt;b.x:a.y&gt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,t,x;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;op[i].q&gt;&gt;t&gt;&gt;x&gt;&gt;op[i].n;</span><br><span class="line">		op[i].x=t-x,op[i].y=t+x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(op<span class="number">+1</span>,op+n<span class="number">+1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(op[i].q==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span>(op[i].n)&#123;</span><br><span class="line">				it=apple.<span class="built_in">lower_bound</span>(op[i]);</span><br><span class="line">				<span class="keyword">if</span>(it==apple.<span class="built_in">end</span>())<span class="keyword">break</span>;</span><br><span class="line">				ans+=<span class="built_in">min</span>(op[i].n,it-&gt;n);</span><br><span class="line">				<span class="keyword">if</span>(op[i].n&lt;it-&gt;n)&#123;</span><br><span class="line">					P tmp=*it;</span><br><span class="line">					apple.<span class="built_in">erase</span>(it);</span><br><span class="line">					tmp.n-=op[i].n;</span><br><span class="line">					apple.<span class="built_in">insert</span>(tmp);</span><br><span class="line">					op[i].n=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(op[i].n==it-&gt;n)&#123;</span><br><span class="line">					op[i].n=<span class="number">0</span>;</span><br><span class="line">					apple.<span class="built_in">erase</span>(it);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					op[i].n-=it-&gt;n;</span><br><span class="line">					apple.<span class="built_in">erase</span>(it);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			apple.<span class="built_in">insert</span>(op[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>二分题型分为 整数和二分答案两种；(此节只讲二分模板和二分答案)</p>
<p>二分的类型为两类 <strong>大于等于最小值</strong>  和  <strong>小于等于最大值</strong>。</p>
<p>二分首先要满足单调性，根据单调性每次取区间的中间值判断是否满足条件，然后缩短一半区间以此循环。<strong>核心就是找到题目的单调性。</strong></p>
<p>大于等于最小值模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小于等于最大值模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span>   <span class="comment">// check 函数用于判断当前最小值是否符合要求</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; x)           <span class="comment">// 如果当前数小于最小值，则需要进行操作</span></span><br><span class="line">            cnt += x - a[i];    <span class="comment">// 计算需要操作的次数</span></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; k)            <span class="comment">// 如果操作次数超过了 k，则说明当前最小值不符合要求</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="案例1–8688-进击的奶牛"><a href="#案例1–8688-进击的奶牛" class="headerlink" title="案例1–8688 进击的奶牛"></a>案例1–8688 进击的奶牛</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240516204230109.png" alt="image-20240516204230109"></p>
<p>典型二分的小于等于最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> in[<span class="number">100100</span>];<span class="comment">//隔间坐标数组</span></span><br><span class="line"><span class="type">int</span> mp[<span class="number">100010</span>];<span class="comment">//二分每头牛的距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;<span class="comment">//排到牛的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]-mp[cnt<span class="number">-1</span>]&gt;=x||cnt==<span class="number">1</span>)&#123;</span><br><span class="line">            mp[cnt]=in[i];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==c<span class="number">+1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;in[i];</span><br><span class="line">    &#125;<span class="comment">//输入</span></span><br><span class="line">    <span class="built_in">sort</span>(in<span class="number">+1</span>,in<span class="number">+1</span>+n);<span class="comment">//先排序题目 是无序的</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1000000000</span>;<span class="comment">//根据题目范围设立边界</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r<span class="number">+1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">            l=mid;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前缀和和差分"><a href="#前缀和和差分" class="headerlink" title="前缀和和差分"></a>前缀和和差分</h3><blockquote>
<p>什么是前缀和？<br>前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。<br>作用：快速求出某一段区间的总和<br>such as:求出a[3]+a[4]+…+a[15]&#x3D;sum[15]-sum[2] &#x2F;&#x2F;sum为前缀和<br>优势：可以在O(1)的复杂度求出某一部分的总和</p>
</blockquote>
<h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><p>根据上面的定义，我们可以很容易得到 sum[i] &#x3D; sum[i-1] + a[i] 这样就可以得到前i个数的和</p>
<p>根据上述表达式我们可以以O(1)求出区间[i,j]的区间和</p>
<p><strong>sum[i,j]&#x3D;sum[j]-sum[i-1]</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在原数组中求前缀和</span></span><br><span class="line"><span class="comment">//注意：a[0] = 0;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    a[i] += a[i - <span class="number">1</span>];</span><br><span class="line"><span class="comment">//另开一个数组存前缀和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] + a[i];</span><br></pre></td></tr></table></figure>

<p><strong>差分可以看成前缀和的逆运算</strong>。</p>
<p>差分数组转化为前缀和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    b[i] += b[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>



<h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p>二维前缀和定义：</p>
<p><img src="https://s1.ax1x.com/2020/05/07/YmD5Is.png" alt="推导公式"></p>
<p>如果根据定义求显然过于麻烦。可以用数学推导更简单的方法。</p>
<p><strong>sum[i][j]&#x3D;a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]</strong></p>
<h4 id="原数组求前缀和"><a href="#原数组求前缀和" class="headerlink" title="原数组求前缀和"></a>原数组求前缀和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">        s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br></pre></td></tr></table></figure>

<h4 id="差分数组转化为前缀和"><a href="#差分数组转化为前缀和" class="headerlink" title="差分数组转化为前缀和"></a>差分数组转化为前缀和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m;j ++)</span><br><span class="line">        b[i][j] += b[i][j - <span class="number">1</span>] + b[i - <span class="number">1</span>][j] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/16/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E8%AE%B2/%E8%B4%AA%E5%BF%83%E4%BA%8C%E5%88%86%E5%89%8D%E7%BC%80%E5%92%8C%E5%B7%AE%E5%88%86/" data-id="cm23pcg0v000h362z731ra0ky" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第4讲/hashkmp字典树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/15/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E8%AE%B2/hashkmp%E5%AD%97%E5%85%B8%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2024-07-14T17:05:58.000Z" itemprop="datePublished">2024-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p>哈希表用于快速地存储和查询数据，而数据类型是多样的。<br>当 数据类型为字符 时，就可以使用字符串哈希。</p>
<blockquote>
<p>当然，直接 存储一个很长的字符串需要 大量空间，<br>在本模板中，会将每个字符串 转换为相应的数值 。 </p>
</blockquote>
<h4 id="一、模拟哈希表"><a href="#一、模拟哈希表" class="headerlink" title="一、模拟哈希表"></a>一、模拟哈希表</h4><p>哈希表 ( 也称为散列表 ) 是一种具有特殊的数据 存储 和 查找 方式的 数组 。</p>
<p>1.对于将要 存储 的数据 x ，哈希表通过一种 映射关系 ( 哈希函数 f(x) ) ，计算出 该数据在数组中的 下标 k &#x3D; f(x) ，将其保存 h[ k ] &#x3D; x。	</p>
<p>2.若要 查找 数据 x 是否在哈希表中，就能通过同样的哈希函数，直接计算 出其对应的下标 k &#x3D; f(x) ，判断 h[k] 存储的是否是该元素。</p>
<p>相比于一般的数组，哈希表中元素的查找能 免去大量的比较操作 。</p>
<blockquote>
<p>类比一般的一维数组：</p>
<p>一维数组 会随着 下标 的递增，顺序 地存储数据。<br>若要判断某个数据是否属于该数组，<br>则需从第一个数组元素开始，逐个比较，以判断是否存在该元素。</p>
</blockquote>
<h4 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h4><p>维护一个集合，支持如下几种操作：</p>
<p>1.插入一个数 x ；<br>2.询问数 x 是否在集合中出现过；</p>
<h4 id="三、哈希表的核心-——-哈希函数"><a href="#三、哈希表的核心-——-哈希函数" class="headerlink" title="三、哈希表的核心 —— 哈希函数"></a>三、哈希表的核心 —— 哈希函数</h4><p>哈希表通过 哈希函数 ，可以将一个 大范围 的数据，映射到一个 较小的范围 。</p>
<p>说明：</p>
<p>哈希函数 将每个数据对应到数组中的一个 下标 ，使得 查找元素 操作的时间复杂度接近 O(1) 。</p>
<p>但相应的，我们需要为每个元素提供其 对应的 存储空间。<br>又因为静态数组的大小从一开始就固定，因此若数据元素与下标 一 一对应，且数据可能的范围很大，则初始时就需要开辟很大的数组。</p>
<blockquote>
<p>例如：要存储的数据 10^(-9) &lt; x &lt; 10 ^ 9，则需要开辟大小为 2 * 10^9 的数组。</p>
</blockquote>
<p>但大多数情况下，虽然数据的范围很大，但是数据的 数量很少 ，<br>以举例中的方式存储，则会有很多的 空间浪费 。</p>
<p>因此我们就需要合理设计哈希函数，将大范围的数据映射到一个较小的区间，这样既能快速查找，又能有效利用空间。</p>
<blockquote>
<p>例如：有 5 个数据，对于任意的数据 x ∈ ( 10^(-9) , 10^9 )<br>则只需要开辟大小 至少 为 5 的数组，就能全部存储了。</p>
</blockquote>
<h4 id="四、哈希函数的设计"><a href="#四、哈希函数的设计" class="headerlink" title="四、哈希函数的设计"></a>四、哈希函数的设计</h4><p>实际工作中需视不同的情况采用不同的哈希函数。</p>
<p>在本模板中，我们使用简单的 取余操作 ( mod &#x2F; % ) 作为哈希函数。</p>
<p>说明：</p>
<p>对于任意大小的数 x，设定区间大小 N，则 x mod N ∈ [ 0, N - 1 ] 。<br>由此便将大范围的数 x ，映射到小范围 [ 0, N - 1 ] 中 。</p>
<p><img src="https://cdn.acwing.com/media/article/image/2022/02/16/126788_b842145b8f-%E5%93%88%E5%B8%8C%E8%A1%A81.jpg" alt="哈希表1.jpg"></p>
<p>{:height&#x3D;”70%” width&#x3D;”70%”}</p>
<blockquote>
<p>举例：哈希表 h[N] ，大小 N &#x3D; 10 ，哈希函数 f(x) &#x3D; x % 10</p>
<p>存储数据 x &#x3D; 62 ，<br>下标 k &#x3D; f(x) &#x3D; 62 % 10 &#x3D; 2 ，因此 h[k] &#x3D; h[2] &#x3D; 62</p>
<p>查询数据 x &#x3D; 16 是否存在：<br>下标k &#x3D; f(x) &#x3D; 16 % 10 &#x3D; 6 ，h[k] &#x3D; h[6] &#x3D;&#x3D; 16 查询成功</p>
<p>查询数据 x &#x3D; 71 是否存在：<br>下标k &#x3D; f(x) &#x3D; 71 % 10 &#x3D; 1 ，h[k] &#x3D; h[1] &#x3D;&#x3D; null ，不存在该数据。</p>
</blockquote>
<p><strong>对取模运算中模数的要求</strong><br>在使用哈希表时，取模运算中的模数一般要取质数，而且这个质数要离 2 的整数次幂尽可能远。</p>
<p><strong>这么取发生冲突的概率最小。( 可通过数学方法证明 )</strong></p>
<p>模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P=<span class="number">131</span>,N=<span class="number">1000100</span>;</span><br><span class="line">ULL p[N],h[N];<span class="comment">//用unsigned long long打底就不会出现负数</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::string s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//预处理,一个是求p的i次方 另一个是求 原串的用p的i次方打底</span></span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>,h[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;s[i];i++)&#123;</span><br><span class="line">        p[i]=p[i<span class="number">-1</span>]*P;</span><br><span class="line">        h[i]=h[i<span class="number">-1</span>]*P+s[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//通过数学公式推导</span></span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">substr</span><span class="params">(<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span> l2,<span class="type">int</span> r2)</span></span>&#123;<span class="comment">//判断两段字符是否相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(l1,r1)==<span class="built_in">get</span>(l2,r2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>这是一个字符串匹配算法，对暴力一一比对的方法进行了优化，使时间复杂度大大降低。</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>1、s[ ]是模式串，即比较长的字符串。<br>2、p[ ]是模板串，即比较短的字符串。（这样可能不严谨。。。）<br>3、前缀：指除了最后一个字符以外，一个字符串的全部头部组合。<br>4、后缀：指除了第一个字符以外，一个字符串的全部尾部组合。<br>5、部分匹配值：前缀和后缀的最长共有元素的长度。<br>6、next[ ]是“部分匹配值表”，即next数组，它存储的是每一个下标对应的“部分匹配值”，是KMP算法的核心。（后面作详细讲解）。</p>
<p><strong>核心思想</strong>：KMP的效率在于它能够跳过不匹配的字符，而不是简单地将模式串（p串）向后移动一位。当发生失配时，KMP利用一个辅助数组（通常称为next数组或失败函数），来确定模式串应该向后移动多远，以便下一次能够与文本串（t串）的前面部分重新匹配。这种方法可以显著减少不必要的比较操作，提高字符串匹配的效率。简而言之，KMP通过智能地跳过不匹配的部分，加速了字符串的搜索过程。</p>
<h4 id="Next数组含义"><a href="#Next数组含义" class="headerlink" title="Next数组含义"></a>Next数组含义</h4><p>对next[ j ] ，是p[ 1, j ]串中前缀和后缀相同的最大长度（部分匹配值），即 p[ 1, next[ j ] ] &#x3D; p[ j - next[ j ] + 1, j ]。如下图:</p>
<p><img src="https://cdn.acwing.com/media/article/image/2020/06/12/31041_6f934f82ac-next%E4%BE%8B%E5%AD%90.PNG" alt="next例子.PNG"></p>
<p>手动模拟求next数组：</p>
<p>对 p &#x3D; “abcab”</p>
<table>
<thead>
<tr>
<th>p</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>next数组</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<p>对next[ 1 ] ：前缀 &#x3D; 空集—————后缀 &#x3D; 空集—————next[ 1 ] &#x3D; 0;</p>
<p>对next[ 2 ] ：前缀 &#x3D; { a }—————后缀 &#x3D; { b }—————next[ 2 ] &#x3D; 0;</p>
<p>对next[ 3 ] ：前缀 &#x3D; { a , ab }—————后缀 &#x3D; { c , bc}—————next[ 3 ] &#x3D; 0;</p>
<p>对next[ 4 ] ：前缀 &#x3D; { a , ab , abc }—————后缀 &#x3D; { a . ca , bca }—————next[ 4 ] &#x3D; 1;</p>
<p>对next[ 5 ] ：前缀 &#x3D; { a , ab , abc , abca }————后缀 &#x3D; { b , ab , cab , bcab}————next[ 5 ] &#x3D; 2;</p>
<h4 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">char</span> p[N], s[N]; <span class="comment">// 用 p 来匹配 s</span></span><br><span class="line"><span class="comment">// “next” 数组，若第 i 位存储值为 k</span></span><br><span class="line"><span class="comment">// 说明 p[0...i] 内最长相等前后缀的前缀的最后一位下标为 k</span></span><br><span class="line"><span class="comment">// 即 p[0...k] == p[i-k...i]</span></span><br><span class="line"><span class="type">int</span> ne[N]; </span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n 是模板串长度 m 是模式串长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="comment">// p[0...0] 的区间内一定没有相等前后缀</span></span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 构造模板串的 next 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; p[i] != p[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若前后缀匹配不成功</span></span><br><span class="line">            <span class="comment">// 反复令 j 回退，直至到 -1 或是 s[i] == s[j + 1]</span></span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) </span><br><span class="line">        &#123;</span><br><span class="line">            j ++; <span class="comment">// 匹配成功时，最长相等前后缀变长，最长相等前后缀前缀的最后一位变大</span></span><br><span class="line">        &#125;</span><br><span class="line">        ne[i] = j; <span class="comment">// 令 ne[i] = j，以方便计算 next[i + 1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// kmp start !</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] != p[j + <span class="number">1</span>])</span><br><span class="line">       &#123;</span><br><span class="line">           j = ne[j];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>])</span><br><span class="line">       &#123;</span><br><span class="line">           j ++; <span class="comment">// 匹配成功时，模板串指向下一位</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (j == n - <span class="number">1</span>) <span class="comment">// 模板串匹配完成，第一个匹配字符下标为 0，故到 n - 1</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 匹配成功时，文本串结束位置减去模式串长度即为起始位置</span></span><br><span class="line">           cout &lt;&lt; i - j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 模板串在模式串中出现的位置可能是重叠的</span></span><br><span class="line">           <span class="comment">// 需要让 j 回退到一定位置，再让 i 加 1 继续进行比较</span></span><br><span class="line">           <span class="comment">// 回退到 ne[j] 可以保证 j 最大，即已经成功匹配的部分最长</span></span><br><span class="line">           j = ne[j]; </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="KMP算法求循环节"><a href="#KMP算法求循环节" class="headerlink" title="KMP算法求循环节"></a>KMP算法求循环节</h3><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240712175929141.png" alt="image-20240712175929141"></p>
<h4 id="next数组的含义"><a href="#next数组的含义" class="headerlink" title="next数组的含义"></a><code>next</code>数组的含义</h4><p><code>next</code>数组是KMP算法中的一个关键组成部分，它用于存储字符串中每个位置之前的子字符串与字符串本身的匹配信息。<code>next[i]</code>的值表示字符串<code>S[1~i]</code>中最长的相同前缀和后缀的长度。</p>
<h4 id="求循环节的方法"><a href="#求循环节的方法" class="headerlink" title="求循环节的方法"></a>求循环节的方法</h4><ol>
<li><p><strong>初始化</strong>：首先，计算给定字符串<code>S</code>的<code>next</code>数组。</p>
</li>
<li><p><strong>分析<code>next</code>数组</strong>：</p>
<ul>
<li>如果<code>S[1~i]</code>具有长度为<code>len</code>的循环节，其中<code>len &lt; i</code>，则<code>S[1~i-len]</code>等于<code>S[i-len+1~i]</code>。</li>
</ul>
</li>
<li><p><strong>寻找最小循环节</strong>：</p>
<ul>
<li>遍历<code>next</code>数组，寻找满足<code>i % (i - next[i]) == 0</code>的位置<code>i</code>。这个条件确保了<code>S[1~i-next[i]]</code>是<code>S[1~i]</code>的最小循环节。</li>
<li>循环节的最大重复次数可以通过<code>i / (i - next[i])</code>来计算。</li>
</ul>
</li>
<li><p><strong>寻找次小循环节</strong>：</p>
<ul>
<li>如果<code>i - next[i]</code>能够整除<code>i</code>，并且<code>i - next[next[i]]</code>也能整除<code>i</code>，那么<code>S[1~i - next[next[i]]]</code>就是<code>S[1~i]</code>的次小循环节。</li>
</ul>
</li>
<li><p><strong>继续寻找其他循环节</strong>：</p>
<ul>
<li>通过递归地应用上述步骤，可以找到<code>S[1~i]</code>的所有可能的循环节。</li>
</ul>
</li>
</ol>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>以字符串<code>S = &quot;abababab&quot;</code>为例：</p>
<ul>
<li>计算<code>next</code>数组：<code>next[8] = 6</code>，<code>next[6] = 4</code>，<code>next[4] = 2</code>，<code>next[2] = 0</code>。</li>
<li><code>next[8] = 6</code>表明<code>S[1~6]</code>是<code>S[7~8]</code>的后缀，但不是循环节。</li>
<li><code>next[6] = 4</code>表明<code>S[1~4]</code>是<code>S[5~6]</code>的后缀，且<code>8 % (8 - 4) == 0</code>，所以<code>S[1~4]</code>是<code>S[1~8]</code>的一个循环节，重复次数为<code>8 / (8 - 4) = 2</code>。</li>
<li>继续分析<code>next[4]</code>和<code>next[2]</code>，可以找到更小的循环节。</li>
</ul>
<h3 id="字典树（Trie）概述"><a href="#字典树（Trie）概述" class="headerlink" title="字典树（Trie）概述"></a>字典树（Trie）概述</h3><p><strong>字典树</strong>，也称为前缀树或Trie树，是一种用于高效存储和检索字符串集合的数据结构。它常用于实现字符串的快速查找和自动补全功能。</p>
<h3 id="字典树的特点"><a href="#字典树的特点" class="headerlink" title="字典树的特点"></a>字典树的特点</h3><ul>
<li>每个节点可以有多个子节点，通常对应于字符集中的每个字符。<ul>
<li>从根节点到某一节点的路径表示一个字符串的前缀。</li>
</ul>
</li>
</ul>
<p> <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240712191047205.png" alt="image-20240712191047205"></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>  以图片中的例子为参考，展示如何构建字典树并进行插入和检索操作：</p>
<ol>
<li><strong>初始化</strong>：创建一个根节点。</li>
<li><strong>插入</strong>：<ul>
<li>插入”cos”：从根节点开始，依次添加c、o、s，每个字符创建新节点，最后标记s为字符串末尾。</li>
<li>插入”car”：从根节点开始，c已存在，接着添加a、r，最后标记r为末尾。</li>
<li>以此类推，插入其他字符串。</li>
</ul>
</li>
<li><strong>检索</strong>：<ul>
<li>检索”cat”：从根节点开始，依次查找c、a、t，如果每个字符对应的指针都存在，并且t节点被标记为末尾，则”cat”存在。</li>
</ul>
</li>
</ol>
<h3 id="字典树的基本操作"><a href="#字典树的基本操作" class="headerlink" title="字典树的基本操作"></a>字典树的基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> trie[SIZE][<span class="number">26</span>], tot = <span class="number">1</span>;  <span class="comment">// 初始化，假设字符串由小写字母构成</span></span><br><span class="line"><span class="type">int</span> end[SIZE];  <span class="comment">// 标记末尾节点数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str), p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">        <span class="type">int</span> ch = str[k] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;  <span class="comment">// 如果当前字符指针为空，则创建新节点</span></span><br><span class="line">        p = trie[p][ch];  <span class="comment">// 移动到子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    end[p] +=<span class="number">1</span>;  <span class="comment">// 标记末尾节点数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检索字符串是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str), p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">        p = trie[p][str[k] - <span class="string">&#x27;a&#x27;</span>];  <span class="comment">// 移动到对应的子节点</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果字符指针为空，则字符串不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end[p];  <span class="comment">// 检查末尾标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>创建一个空的字典树，只包含一个根节点，所有字符指针都指向空。</li>
</ul>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ol>
<li>创建一个指针<code>P</code>指向根节点。</li>
<li>遍历要插入的字符串<code>S</code>中的每个字符<code>C</code>：<ul>
<li>如果<code>P</code>的字符<code>C</code>指针指向一个存在的节点<code>Q</code>，则<code>P=Q</code>。</li>
<li>如果<code>P</code>的字符<code>C</code>指针为空，则新建一个节点<code>Q</code>，并将<code>P</code>的字符<code>C</code>指针指向<code>Q</code>，然后<code>P=Q</code>。</li>
</ul>
</li>
<li>当字符串<code>S</code>的所有字符扫描完毕，在当前节点<code>P</code>上标记它为字符串的末尾。</li>
</ol>
<h4 id="检索操作"><a href="#检索操作" class="headerlink" title="检索操作"></a>检索操作</h4><ol>
<li>创建一个指针<code>P</code>指向根节点。</li>
<li>遍历要检索的字符串<code>S</code>中的每个字符<code>C</code>：<ul>
<li>如果<code>P</code>的字符<code>C</code>指针为空，则<code>S</code>没有被插入过字典树，检索结束。</li>
<li>如果<code>P</code>的字符<code>C</code>指针指向一个存在的节点<code>Q</code>，则<code>P=Q</code>。</li>
</ul>
</li>
<li>当字符串<code>S</code>的所有字符扫描完毕，如果当前节点<code>P</code>被标记为字符串的末尾，则<code>S</code>在字典树中存在；否则，<code>S</code>没有被插入该字典树。</li>
</ol>
<h3 id="字典树的实现细节"><a href="#字典树的实现细节" class="headerlink" title="字典树的实现细节"></a>字典树的实现细节</h3><ul>
<li><p>每个节点通常包含一个指向字符集大小（例如26个字母）的字符指针数组。</p>
</li>
<li><p>节点可能包含一个额外的标记或数据结构，用于指示该节点是否是某个字符串的末尾。</p>
</li>
</ul>
<p>案例引用–前缀统计</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240712193634893.png" alt="image-20240712193634893"></p>
<p>题解：查询时遍历的过程加上以此点结尾的字符串数量。具体看下文代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 1000100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> trie[SIZE][<span class="number">26</span>], tot = <span class="number">1</span>;  <span class="comment">// 初始化，假设字符串由小写字母构成</span></span><br><span class="line"><span class="type">int</span> cnt[SIZE];  <span class="comment">// 标记末尾节点数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str), p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">        <span class="type">int</span> ch = str[k] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;  <span class="comment">// 如果当前字符指针为空，则创建新节点</span></span><br><span class="line">        p = trie[p][ch];  <span class="comment">// 移动到子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] +=<span class="number">1</span>;  <span class="comment">// 标记末尾节点数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前缀的数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str), p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">        p = trie[p][str[k] - <span class="string">&#x27;a&#x27;</span>];  <span class="comment">// 移动到对应的子节点</span></span><br><span class="line">        ans+=cnt[p];</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> ans;  <span class="comment">// 如果字符指针为空，则字符串不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;  <span class="comment">// 检查末尾标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);<span class="comment">//此两行代码添加快读</span></span><br><span class="line">   <span class="type">char</span> ch[<span class="number">1000100</span>];</span><br><span class="line">   <span class="type">int</span> n,m;</span><br><span class="line">   cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">       cin&gt;&gt;ch;</span><br><span class="line">       <span class="built_in">insert</span>(ch);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">       cin&gt;&gt;ch;</span><br><span class="line">       cout&lt;&lt;<span class="built_in">search</span>(ch)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/15/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E8%AE%B2/hashkmp%E5%AD%97%E5%85%B8%E6%A0%91/" data-id="cm23pcg0v000m362z3d7g6diq" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第3讲/洪水覆盖 记忆化  双向bfs 双向dfs 启发式搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/14/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E8%AE%B2/%E6%B4%AA%E6%B0%B4%E8%A6%86%E7%9B%96%20%E8%AE%B0%E5%BF%86%E5%8C%96%20%20%E5%8F%8C%E5%90%91bfs%20%E5%8F%8C%E5%90%91dfs%20%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2024-07-13T19:11:44.000Z" itemprop="datePublished">2024-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Flood-Fill洪水覆盖问题"><a href="#Flood-Fill洪水覆盖问题" class="headerlink" title="Flood Fill洪水覆盖问题"></a>Flood Fill洪水覆盖问题</h2><blockquote>
<p>用于求连通块相关性质,如统计连通块数目，大小等<br>拥有线性的时间复杂度</p>
</blockquote>
<p><strong>洪水覆盖是一种bfs就像洪水往四周溢一样搜索。</strong></p>
<p>代码流程:<br>特殊处理q[0]后-&gt;队列+条件判断可</p>
<p><strong>案例引用</strong></p>
<p><strong>山峰和山谷</strong></p>
<p>【题目描述】<br>给定一个 n×n 的网格状地图，每个方格 (i,j)有一个高度 w[i][j] 。如果两个方格有公共顶点，则它们是相邻的。</p>
<p>定义山峰和山谷如下：</p>
<p>均由地图上的一个连通块组成；</p>
<p>所有方格高度都相同；</p>
<p>周围的方格（即不属于山峰或山谷但与山峰或山谷相邻的格子）高度均大于山谷的高度，或小于山峰的高度。</p>
<p>求地图内山峰和山谷的数量。特别地，如果整个地图方格的高度均相同，则整个地图既是一个山谷，也是一个山峰。</p>
<p>【输入】<br>第一行一个整数n（2≤n≤1000），表示地图的大小。</p>
<p>接下来 n 行每行 n 个整数表示地图。第 i 行有 n 个整数 wi1,wi2,…,win(0≤wij≤1000000000)，表示地图第 i 行格子的高度。</p>
<p>【输出】<br>输出一行两个整数，分别表示山峰和山谷的数量。</p>
<p>【输入样例】<br>输入样例1</p>
<p>5<br>8 8 8 7 7<br>7 7 8 8 7<br>7 7 7 7 7<br>7 8 8 7 8<br>7 8 8 8 8</p>
<p>输入样例2：</p>
<p>5<br>5 7 8 3 1<br>5 5 7 6 6<br>6 6 6 2 8<br>5 7 2 5 8<br>7 1 0 1 7</p>
<p>【输出样例】<br>输出样例1：</p>
<p>2 1</p>
<p>样例解释：</p>
<p><img src="https://img-blog.csdnimg.cn/20200202192024789.gif" alt="img"></p>
<p>输出样例2：</p>
<p>3 3</p>
<p>样例解释：</p>
<p><img src="https://img-blog.csdnimg.cn/20200202192032715.gif" alt="img"></p>
<p>思路：</p>
<p>暴搜所有一个点之间所有高度相等的点，如果周围的点都高于或低于当前点，那么这个就是一个山谷或山峰。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将所有整型定义成long long 防越。尽管这道题不会.</span></span><br><span class="line"><span class="comment">x，y是替换pair里的first和second 这样让代码更加直观</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> PII = pair &lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这边using操作和typedef的作用一样给pair重命名 减少码量   </span></span><br><span class="line"><span class="comment">并记录在搜索过程中，记录周围是否有高点和低点：</span></span><br><span class="line"><span class="comment">在搜索过程中，判断周围点的情况：</span></span><br><span class="line"><span class="comment">如过和当前点等高，则加入 bfs 队列。</span></span><br><span class="line"><span class="comment">如果比当前点高，记录下来。</span></span><br><span class="line"><span class="comment">如果比当前点地，记录下来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span> <span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy,<span class="type">bool</span> &amp;hh,<span class="type">bool</span> &amp;hl)</span> </span>&#123;</span><br><span class="line">    queue &lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span> (&#123;sx,sy&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span> ()) &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span> ();</span><br><span class="line">        q.<span class="built_in">pop</span> ();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.x - <span class="number">1</span>;i &lt;= t.x + <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.y - <span class="number">1</span>;j &lt;= t.y + <span class="number">1</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; n || j &lt; <span class="number">1</span> || j &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (h[i][j] != h[t.x][t.y]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (h[i][j] &gt; h[t.x][t.y]) hh = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> hl = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!st[i][j]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span> (&#123;i,j&#125;);</span><br><span class="line">                    st[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)  </span><br><span class="line">            cin &gt;&gt; h[i][j];</span><br><span class="line">    <span class="type">int</span> high = <span class="number">0</span>,low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j]) &#123;</span><br><span class="line">                <span class="type">bool</span> hh = <span class="literal">false</span>,hl = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bfs</span> (i,j,hh,hl);</span><br><span class="line">                low+=!hl,high+=!hh;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; high &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; low &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记忆化搜索是一种优化搜索算法的技术，它通过存储已经计算过的结果来避免重复计算，从而提高搜索效率。这种方法通常用于解决具有重叠子问题特性的问题，例如动态规划问题。</p>
<h3 id="记忆化搜索的基本概念："><a href="#记忆化搜索的基本概念：" class="headerlink" title="记忆化搜索的基本概念："></a>记忆化搜索的基本概念：</h3><ol>
<li><p><strong>重叠子问题</strong>：在搜索过程中，相同的子问题被多次求解。记忆化搜索通过存储这些子问题的解来避免重复计算。</p>
</li>
<li><p><strong>最优子结构</strong>：问题可以分解为更小的子问题，这些子问题的解组合起来可以得到原问题的解。</p>
</li>
<li><p><strong>存储结构</strong>：通常使用一个数组或哈希表来存储子问题的解。索引通常由子问题的参数决定。</p>
</li>
</ol>
<h3 id="记忆化搜索的步骤："><a href="#记忆化搜索的步骤：" class="headerlink" title="记忆化搜索的步骤："></a>记忆化搜索的步骤：</h3><ol>
<li><p><strong>确定状态</strong>：定义问题的解空间，即状态。</p>
</li>
<li><p><strong>确定状态转移方程</strong>：找到状态之间的关系，即从一个状态如何转移到另一个状态。</p>
</li>
<li><p><strong>初始化记忆化表</strong>：创建一个数据结构（如数组或哈希表）来存储子问题的解。</p>
</li>
<li><p><strong>实现递归函数</strong>：编写一个递归函数来计算问题的解。在递归过程中，首先检查当前状态的解是否已经计算过并存储在记忆化表中。如果是，则直接使用存储的解；如果不是，则计算解并存储在记忆化表中。</p>
</li>
<li><p><strong>回溯</strong>：递归函数在计算完当前状态的解后，回溯并继续计算其他状态的解。</p>
</li>
</ol>
<h3 id="示例：斐波那契数列"><a href="#示例：斐波那契数列" class="headerlink" title="示例：斐波那契数列"></a>示例：斐波那契数列</h3><p>斐波那契数列是一个经典的动态规划问题，可以通过记忆化搜索来解决。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n, memo=&#123;&#125;</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    memo[n] = fib(n-<span class="number">1</span>, memo) + fib(n-<span class="number">2</span>, memo)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fib</code> 函数计算斐波那契数列的第 <code>n</code> 项。通过使用一个字典 <code>memo</code> 来存储已经计算过的斐波那契数，我们可以避免重复计算，从而显著提高计算效率。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li><p><strong>提高效率</strong>：通过避免重复计算，记忆化搜索可以显著减少计算时间。</p>
</li>
<li><p><strong>适用性广</strong>：适用于具有重叠子问题和最优子结构特性的问题。</p>
</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><p><strong>空间复杂度</strong>：需要额外的空间来存储子问题的解，这可能会增加空间复杂度。</p>
</li>
<li><p><strong>实现复杂性</strong>：相比于简单的递归或迭代，记忆化搜索的实现可能更复杂。</p>
</li>
</ul>
<p>记忆化搜索是一种强大的技术，可以用于解决许多复杂的优化问题。通过合理地应用记忆化搜索，可以有效地提高算法的效率。</p>
<h3 id="双向搜索问题"><a href="#双向搜索问题" class="headerlink" title="双向搜索问题"></a>双向搜索问题</h3><p>很多情况，让我们从起点搜索到终点找到最少的路径长度，一般的dfs或者bfs的搜索树非常庞大，效率低下。</p>
<p>如图所示</p>
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240522205838711.png" alt="image-20240522205838711" style="zoom: 67%;" />

<p><strong>而双向搜索就是既然终点是已知的了那就不让终点闲下来，终点也一起搜。</strong></p>
<p><strong>分别</strong>从起点和终点出发，看它们能否<strong>相遇</strong>。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240522205825226.png" alt="image-20240522205825226"></p>
<p>如果原来的搜索树规模是a^n^,使用双向搜索后规模会缩小到大概2a^n&#x2F;2^，相对于朴素BFS有比较大的优化。</p>
<h2 id="双向广搜"><a href="#双向广搜" class="headerlink" title="双向广搜"></a>双向广搜</h2><blockquote>
<p>与普通的BFS不同，双向BFS维护两个而不是一个队列，然后<strong>轮流</strong>拓展两个队列。同时，用<strong>数组</strong>（如果状态可以被表示为较小的整数）或<strong>哈希表</strong>记录当前的搜索情况，给从两个方向拓展的节点以不同的标记。当某点被两种<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%A0%87%E8%AE%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22119349440%22%7D">标记</a>同时标记时，搜索结束。</p>
</blockquote>
<p>1.双向广搜适用场景是bfs的搜索空间过大，如果仅从一个方向搜索的话占用空间大，效率低。<br>2.在搜索空间成指数级增长时较为实用，本质是对普通bfs的一种优化。<br>3.算法的关键是建立两个队列，分别从开始和结尾进行扩展，按照队列大小的顺序进行扩展，即先扩展小队列。算法结束的条件是新扩展的元素出现在另外一个队列之中，那么就找到了答案。<br>4.在字符串bfs问题中常用哈希表来表示一个字符串从开始到当前经历了多少步。</p>
<p><strong>注意点：双向广搜需要每次扩展一层而不是一个点</strong></p>
<p>意味着我们需要每次扩展与当前点距离相应原点距离相同的点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;T&gt; Q[<span class="number">3</span>];  <span class="comment">// T为模板代替变量类型，st是起始点的队列，En是终点的队列</span></span><br><span class="line"><span class="type">bool</span> flag= <span class="literal">false</span>;</span><br><span class="line">Q[<span class="number">1</span>].<span class="built_in">push</span>(st); <span class="comment">// 添加起始点</span></span><br><span class="line">Q[<span class="number">2</span>].<span class="built_in">push</span>(ed); <span class="comment">//添加终止点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt;= u + <span class="number">1</span>; ++d) <span class="comment">// u为最大深度，最后答案为d-1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dir = (d &amp; <span class="number">1</span>) + <span class="number">1</span>, sz = Q[dir].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//dir变量是判断搜索的方向，如果1是正方向2是反方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> x = Q[dir].<span class="built_in">front</span>();<span class="comment">//取出队列的头结点</span></span><br><span class="line">        Q[dir].<span class="built_in">pop</span>();</span><br><span class="line">        map[x] = dir;<span class="comment">//打上标记</span></span><br><span class="line">        <span class="comment">// map是哈希数组，如果该点被搜了，就打上标记，map[x]+dir,如果等于3说明两个点都被搜了 扎到</span></span><br><span class="line">        flag += map[x]==<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 这里需要把当前状态能够转移到的新状态压入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h2><p>思想很简单，就是控制搜索的深度，如果大于最大深度就返回。如果某个深搜完后没有得到答案就让最大深度加1，重新开始搜索。</p>
<h4 id="下面的例题举个例子"><a href="#下面的例题举个例子" class="headerlink" title="下面的例题举个例子"></a>下面的例题举个例子</h4><p> <strong>题面</strong>:</p>
 <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240523193120897.png" style="zoom:80%;" />

<p> <strong>输入描述：</strong></p>
<p> 输入一个整数n(1≤n≤100)。</p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>n小于100可以考虑暴搜，但是此题一般的dfs搜索过不了，因为递归的层数会过深，但是答案很短。举个例子</p>
<p>1  2  3  5  8  13  21  34  55  89  144</p>
<p> 长度只有11，但是很容易构造出一个递增的序列，可以达到 144项。为了避免这样的不必要搜索。</p>
<p>于是<strong>迭代加深搜索</strong>就演变出来了。</p>
<p><strong>迭代加深搜索适合搜索规模不定，但是答案在较浅的层数的问题。</strong></p>
<p>虽然该过程中深度限制为时，会重复搜索1~d-1层的节点，但是当搜索树节点分支数目较多时，<br>随着层数的深入，每层节点数会呈指数级增长，重复搜索量相比于深层子树的规模就是毛毛雨。</p>
<p>搜索框架：依次搜索序列中的每个位置k,枚举i和j作为分支，path[i]和path[j]们的和填到 path[k]上，然后递归填写下一个位置。</p>
<p>为了简便搜索加了一些剪枝的操作，具体可看代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span>  <span class="comment">// u表示当前层数, k表示最大的层数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> path[u - <span class="number">1</span>] == n; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//对于不同的i和j,path[i]+path[j]可能是相等的.我们可以在枚举时用一个boo数组对</span></span><br><span class="line"><span class="comment">//X[i]+X[j]进行判重，避免重复搜索某一个和.</span></span><br><span class="line">    <span class="type">bool</span> st[N] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 通过 bool数组排除等效冗余</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//从大到小枚举 为了尽管趋近u</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> s = path[i] + path[j];</span><br><span class="line">            <span class="keyword">if</span> (s &gt; n || s &lt;= path[u - <span class="number">1</span>] || st[s]) &#123; <span class="comment">// path一定是递增的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            st[s]   = <span class="literal">true</span>;</span><br><span class="line">            path[u] = s;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>, k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>, k)) &#123;  <span class="comment">// 不断扩大范围</span></span><br><span class="line">    k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        cout &lt;&lt; path[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>题目描述</strong><br>在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。<br><strong>输入格式</strong><br>输入初始状态，一行九个数字，空格用0表示<br><strong>输出格式</strong><br>只有一行，该行只有一个数字，表示从初始状态到目标状态需要的最少移动次数(测试数据中无特殊无法到达目标状态数据)<br><strong>输入输出样例</strong><br><strong>输入</strong>  283104765<br><strong>输出</strong>  4</p>
</blockquote>
<h4 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> e[] = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>, <span class="number">10000000</span>, <span class="number">100000000</span>, <span class="number">1000000000</span>&#125;, D;</span><br><span class="line"><span class="type">bool</span> found;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; H;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">at</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> x % e[i + <span class="number">1</span>] / e[i]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">swap_at</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> p, <span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> x - <span class="built_in">at</span>(x, i) * e[i] + <span class="built_in">at</span>(x, i) * e[p]; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> p, <span class="type">int</span> d, <span class="type">int</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (H[x] + dir == <span class="number">3</span>)</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">    H[x] = dir;</span><br><span class="line">    <span class="keyword">if</span> (d == D)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// p表示0的位置，这是比BFS好的一点，用BFS的话要专门开结构体储存p，或者现算</span></span><br><span class="line">    <span class="keyword">if</span> (p / <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">swap_at</span>(x, p, p - <span class="number">3</span>), p - <span class="number">3</span>, d + <span class="number">1</span>, dir);</span><br><span class="line">    <span class="keyword">if</span> (p / <span class="number">3</span> != <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">swap_at</span>(x, p, p + <span class="number">3</span>), p + <span class="number">3</span>, d + <span class="number">1</span>, dir);</span><br><span class="line">    <span class="keyword">if</span> (p % <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">swap_at</span>(x, p, p - <span class="number">1</span>), p - <span class="number">1</span>, d + <span class="number">1</span>, dir);</span><br><span class="line">    <span class="keyword">if</span> (p % <span class="number">3</span> != <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">swap_at</span>(x, p, p + <span class="number">1</span>), p + <span class="number">1</span>, d + <span class="number">1</span>, dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> st, p, ed = <span class="number">123804765</span>;</span><br><span class="line">    cin &gt;&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">0</span>; <span class="built_in">at</span>(st, p); ++p); <span class="comment">// 找到起始状态中0的位置</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(st, p, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (found)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; D * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(ed, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (found)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; D * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        D++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/14/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E8%AE%B2/%E6%B4%AA%E6%B0%B4%E8%A6%86%E7%9B%96%20%E8%AE%B0%E5%BF%86%E5%8C%96%20%20%E5%8F%8C%E5%90%91bfs%20%E5%8F%8C%E5%90%91dfs%20%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/" data-id="cm23pcg0v000j362zc849f51u" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第9讲/状态压缩dp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/13/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC9%E8%AE%B2/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/" class="article-date">
  <time class="dt-published" datetime="2024-07-13T09:39:34.000Z" itemprop="datePublished">2024-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h3><p>状态压缩指的是用一个数字的二进制的0&#x2F;1 来表示所需要的状态<br>由于复杂度是指数级的 2^n 所以一般在n≤25时使用由于二进制每一位只有0&#x2F;1两种可能性<br>所以一般可以表示选与不选<br>另外如果另设一维作为状态转移的途径的话可以转换为状态转移DP<br>状态压缩通常可以将O(n!)复杂度优化为O(2n)</p>
<h4 id="例题-小国王"><a href="#例题-小国王" class="headerlink" title="例题 小国王"></a>例题 小国王</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N=12,K=N*N,M=1&lt;&lt;N;</span><br><span class="line">int n,k;</span><br><span class="line">vector&lt;int&gt;hf;//</span><br><span class="line">vector&lt;int&gt;ge[M];   </span><br><span class="line">int cnt[M];</span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">return!(x&amp;(x&gt;&gt;1));//如果存在连续两个1的话就不合法 否则的话就是合法的</span><br><span class="line">&#125;</span><br><span class="line">int count(int x)&#123;//这里就是计算某个数二进制里面1的个数</span><br><span class="line">    int res=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        res+=(x&gt;&gt;i)&amp;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int f[N][K][M];</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    for(int i=0;i&lt;1&lt;&lt;n;i++)</span><br><span class="line">    if(check(i))&#123;/*check函数是检查一下我们当前状态是不是合法，也就是检查一下我们这个状态里面是不是存在连续的两个1，</span><br><span class="line">    如果不存在的话就表示它是合法的*/</span><br><span class="line">        hf.push_back(i);</span><br><span class="line">        cnt[i]=count(i);//cnt的话存的是这个i里面 1 的个数是多少</span><br><span class="line">    &#125;</span><br><span class="line">     //不同状态之间的一个这个边的关系</span><br><span class="line">    for(auto f1:hf)</span><br><span class="line">    for(auto f2:hf)//用f1来表示第一个状态，用f2来表示第二个状态</span><br><span class="line">    //这里是建立一个不同状态之间的转移关系</span><br><span class="line">          //先预处理一下哪些状态和哪些状态之间可以转移</span><br><span class="line">          //首先转移的话是要满足两个条件对吧</span><br><span class="line">          //一个是这个 f1 和 f2 的交集必须要是空集，它必须是空集才可以，否则的话同一列的两个国王会攻击到</span><br><span class="line">          //并且的话它们的这个这个并集的话也是需要去满足我们不能包含两个相邻的1的</span><br><span class="line">    if(!(f1&amp;f2)&amp;&amp;check(f1|f2))</span><br><span class="line">    ge[f1].push_back(f2);// head[a].push_back(b);</span><br><span class="line">             //然后只要这个 f2 是合法的，那么我们就把 f2 添加到 f1 可以转移到的状态集合里面去</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    f[0][0][0]=1;</span><br><span class="line">    //我们f[0][0][0]=1</span><br><span class="line">      /*什么意思呢，就是说，前0行，我们前0行已经摆完了，也就是一行也没有摆的情况下，</span><br><span class="line">      那么此时由于我们这个是在棋盘外面，</span><br><span class="line">      所以肯定每个国王都不能摆对吧，所以我们就只有0这个状态时合法的，那么这个状态的方案数是1*/</span><br><span class="line"></span><br><span class="line">      //然后从前往后枚举每一种状态</span><br><span class="line">    for(int i=1;i&lt;=n+1;i++)</span><br><span class="line">    for(int j=0;j&lt;=k;j++)</span><br><span class="line">    for(auto f1:hf)</span><br><span class="line">    for(auto f2:ge[f1])</span><br><span class="line">    if(cnt[f1]&lt;=j)</span><br><span class="line">    f[i][j][f1]+=f[i-1][j-cnt[f1]][f2];//转移就是f[i][j][f1]+=f[i-1][j-c][f2]，然后从f2转移过来</span><br><span class="line">    cout&lt;&lt;f[n+1][k][0];</span><br><span class="line">     /*假设存在第n+1行，但是第n+1行完全没有摆，</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/13/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC9%E8%AE%B2/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/" data-id="cm23pcg0w000u362z1lijhc6n" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-位运算递归和递推" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/13/%E4%BD%8D%E8%BF%90%E7%AE%97%E9%80%92%E5%BD%92%E5%92%8C%E9%80%92%E6%8E%A8/" class="article-date">
  <time class="dt-published" datetime="2024-07-13T07:37:46.000Z" itemprop="datePublished">2024-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="位运算知识点介绍："><a href="#位运算知识点介绍：" class="headerlink" title="位运算知识点介绍："></a>位运算知识点介绍：</h3><p>位运算是算法竞赛中的一个常见考点，它涉及到对二进制数位进行操作的一系列技巧和方法。以下是一些在算法竞赛中可能会考察到位运算的方面：</p>
<ol>
<li><strong>基本位运算符的理解与应用</strong>：</li>
</ol>
<p>  - 按位与（&amp;）：对两个数的每一位进行逻辑与操作。</p>
<p>  - 按位或（|）：对两个数的每一位进行逻辑或操作。</p>
<p>  - 按位异或（^）：对两个数的每一位进行异或操作，相同为0，不同为1。</p>
<p>  - 按位取反（~）：对一个数的每一位进行取反操作，0变1，1变0。</p>
<p>  - 左移（&lt;&lt;）：将一个数的所有位向左移动指定的位数。</p>
<p>  - 右移（&gt;&gt;）：将一个数的所有位向右移动指定的位数。</p>
<ol start="2">
<li><strong>位运算的性质和规则</strong>：</li>
</ol>
<p>  - 位运算的优先级。</p>
<p>  - 位运算的结合律和交换律。</p>
<p>  - 位运算在不同数据类型（如int、long long）上的行为。</p>
<ol start="3">
<li><strong>位运算的实际应用</strong>：</li>
</ol>
<p>  - 判断一个数的奇偶性。</p>
<p>  - 交换两个变量的值而不使用额外的存储空间。</p>
<p>  - 计算一个数的二进制表示中1的个数。</p>
<p>  - 判断一个数是否为2的幂次方。</p>
<p>  - 快速幂算法的实现，用于计算大数的幂次方。</p>
<ol start="4">
<li><strong>位运算的优化技巧</strong>：</li>
</ol>
<p>  - 使用位运算进行高效的乘除法运算。</p>
<p>  - 利用位运算优化算法的时间复杂度和空间复杂度。</p>
<ol start="5">
<li><strong>位运算与其他算法的结合</strong>：</li>
</ol>
<p>  - 位运算在动态规划、图论算法、数论算法中的应用。</p>
<p>  - 位运算在解决特定算法问题中的巧妙使用，如处理特定的数据结构或优化搜索过程。</p>
<p>题目a^b</p>
<p>A-  <a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/996/A">a^b_0x01 基本算法-位运算 (nowcoder.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求a的b次方对p取模</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">int</span> b,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;<span class="comment">//要返回的答案，初始化为1是1乘任意数为任意数，不能为0</span></span><br><span class="line">    <span class="keyword">while</span>(b)&#123;<span class="comment">//对b的二进制指数进行枚举</span></span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)&#123; <span class="comment">//b的二进制尾巴是1</span></span><br><span class="line">            ans=(ans*a)%p;</span><br><span class="line">            <span class="comment">//这边主要对指数b进行一个拆分；</span></span><br><span class="line">            <span class="comment">//比如2^10如果直接算要10次</span></span><br><span class="line">            <span class="comment">//我们可以拆分为(2^2)*(2^8)</span></span><br><span class="line">        &#125;</span><br><span class="line">        b=b/<span class="number">2</span>;<span class="comment">//进一步拆分</span></span><br><span class="line">        a=a*a%p;<span class="comment">//我们让a的幂次升高一倍</span></span><br><span class="line">        <span class="comment">//比如a为(2^3) 升高为 (2^6)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a,b,p;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">pow</span>(a%p,b,p)%p;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题目64位整数乘法</p>
<p>龟速乘模板</p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/996/C">C-64位整数乘法_0x01 基本算法-位运算 (nowcoder.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该算法目的就是求大数 a*b%p</span></span><br><span class="line"><span class="comment">因为c++不是python 两个2^64相乘会爆</span></span><br><span class="line"><span class="comment">思想就是 将 b二进制化 从乘法变成加法</span></span><br><span class="line"><span class="comment">比如 求8*6对10取模</span></span><br><span class="line"><span class="comment">可以为 8*2%10+8*4*10</span></span><br><span class="line"><span class="comment">由于我们是循环的进行的 假设8*2%10在上一步中已经求出我们设为a</span></span><br><span class="line"><span class="comment">那8*4%10就可以变为 a*2%10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模乘运算函数，计算 (a * b) % p 的值</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">modMultiply</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 a 和 b 都取模 p，以防止溢出</span></span><br><span class="line">    a %= p;</span><br><span class="line">    b %= p;</span><br><span class="line">    <span class="comment">// 初始化结果为 0</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将 a 乘以 b，并将结果对 p 取模，累加到结果中</span></span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            result = (result + a) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * <span class="number">2</span>) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a, b, p;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">modMultiply</span>(a, b, p);</span><br><span class="line">    cout &lt;&lt;result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种方法的基本思路是将乘法操作分解为一系列的加法和移位操作，同时在每一步中都进行模p运算，以确保数值始终保持在合法范围内。<br>具体来说，算法的步骤如下：</p>
<ol>
<li>将指数b表示为二进制形式，这样可以将其分解为多个2的幂次的和。</li>
<li>初始化结果变量ans为0，用于累加最终的乘积结果。</li>
<li>通过循环遍历指数b的每一位，对于每一位的判断（即b的最低位是否为1），来决定是否将当前的底数a累加到结果ans中，并在每次累加后对ans进行模p运算。</li>
<li>在每次循环中，将底数a左移一位（相当于乘以2），并且同样进行模p运算，以防止a的值过大导致溢出。</li>
<li>同时，将指数b右移一位，继续循环处理下一位，直到b的所有位都被处理完毕。</li>
<li>最终，循环结束后的结果ans即为a乘b对p取模的结果。<br>这种方法的关键在于通过位运算来高效地处理大数乘法，避免了直接计算可能带来的性能问题和溢出风险。通过这种方式，可以快速且准确地计算出64位整数乘法对p取模的结果，这在算法竞赛中是一个非常有用的技巧。</li>
</ol>
<h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><p>定理1：两数相同异或为0</p>
<p>定理2：如果一个组整数的异或和为0，然后任意某个位置分割开的两个异或和是一样的</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例</span><br><span class="line">假设6个整数位 1 2 3 4 5 1</span><br><span class="line">那任意分成两段他们的异或和都一样  </span><br></pre></td></tr></table></figure>

<p>位运算实例练习</p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定两个正整数j和k，求有多少个序列满足下列条件：<br>1.序列中的所有元素都在 $ [0,2^{k}-1] $​ 之间。<br>2.它的所有元素的与运算之和为0。<br>3.它的元素或之和是尽可能大的。<br>答案对10^9^+7取模。</p>
<p>输入格式：<br>第一行一个整数t(1≤t≤10)表示数据组数。<br>每组测试数据包含两个整数和k,意义如题面所述。<br>输出格式：<br>对于每组数据，输出符合条件的序列对10^9^十7取模的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*考虑和最大，则每个数的二进制都为 k 位。</span></span><br><span class="line"><span class="comment">考虑所有数 and等于 0，则每一个数在二进制中有且只有一个 0，且这些 0 的所在位数不相同。</span></span><br><span class="line"><span class="comment">因为有 n 个数，有 k 位，所以有 n^k 种方法。</span></span><br><span class="line"><span class="comment">快速幂即可。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">ll t,n,k;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="comment">//快速幂</span></span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">		a=(a*a)%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">qpow</span>(n,k)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我们逐步分析给定的问题条件。假设有一个序列α。</p>
<p>首先，根据第一个条件，序列中的每个元素αi都在0到2的k次方减1的范围内。这意味着每个元素αi可以被表示为一个k位的二进制数。</p>
<p>接着，考虑第二个条件，由于序列中所有元素的按位与运算结果为0，我们可以推断出，在这些二进制表示中，每一位上都必须至少有一个元素是0。</p>
<p>再来看第三个条件，为了使得元素之和最大，同时满足第二个条件，我们需要将二进制位上的0尽可能地转变为1。</p>
<p>综合这三个条件，我们可以发现，在二进制表示中，每一位上可能有不同的情况出现（一个0和若干个1的组合），总共有n种情况。因此，最终的答案就是n。在编写代码时，记得声明long long类型的变量来存储结果</p>
<h4 id="选数异或"><a href="#选数异或" class="headerlink" title="选数异或"></a>选数异或</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240713152830379.png" alt="image-20240713152830379"></h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240713152904863.png" alt="image-20240713152904863"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240713152936439.png" alt="image-20240713152936439"></p>
<h5 id="异或运算性质"><a href="#异或运算性质" class="headerlink" title="异或运算性质"></a>异或运算性质</h5><p>异或运算有一个重要性质：如果 ( a \oplus b &#x3D; x )，那么 ( b &#x3D; x \oplus a )。这意味着一旦确定了 ( a )，( b ) 的值也就确定了。</p>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>题目要求对一个区间 ( [L, R] ) 进行查询，可以使用动态规划（DP）的思想来解决。定义一个数组 ( f )，其中 ( f_i ) 表示在区间 ( [1, i] ) 内所有满足条件的数对的下界的下标的最大值。通过枚举区间内的每个数 ( a )，并计算 ( a \oplus x )，如果 ( a \oplus x ) 在之前出现过，则更新 ( f ) 数组。</p>
<h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><ol>
<li>使用一个哈希表来记录每个数 ( a[i] \oplus x ) 对应的下标。</li>
<li>遍历数组 ( a )，对于每个元素 ( a[i] )，更新 ( f[i] ) 为 ( f[i-1] ) 和 ( Hash[a[i] \oplus x] ) 中的较大值。</li>
<li>对于每个查询区间 ( [l, r] )，判断 ( f[r] ) 是否大于等于 ( l )，如果是，则输出 <code>yes</code>，否则输出 <code>no</code>。</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>],f[<span class="number">100005</span>];</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Hash;<span class="comment">//记录每一个a[i]^x的最近的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	cin&gt;&gt;a[i];</span><br><span class="line">    	f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],Hash[a[i]^x]);</span><br><span class="line">    	Hash[a[i]]=i;<span class="comment">//哈希一下~</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(f[r]&gt;=l)cout&lt;&lt;<span class="string">&quot;yes\n&quot;</span>;<span class="comment">//左端点在最大下界的左边</span></span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="递推和递归"><a href="#递推和递归" class="headerlink" title="递推和递归"></a>递推和递归</h2><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p><strong>递推</strong>：以问题边界为起点，向原问题正向推导<br><strong>递归</strong>：（有时推导路线难以确定），则将原问题为起点，尝试把状态空间压缩到已知的问题边界，再通过该路线反方向回溯到原问题的方式即递归。</p>
<h4 id="案例1-1621–分形宇宙"><a href="#案例1-1621–分形宇宙" class="headerlink" title="案例1: 1621–分形宇宙"></a>案例1: 1621–分形宇宙</h4><p><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_5ff1dbcf13-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158360726140.png" alt="企业微信截图_17158360726140.png"><br><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_64372d9113-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158361065646.png" alt="企业微信截图_17158361065646.png"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="type">char</span> m[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">d</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">      <span class="type">int</span> n;</span><br><span class="line">      <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">          <span class="type">int</span> size = <span class="built_in">pow</span>(<span class="number">3.0</span>, n<span class="number">-1</span>);<span class="comment">//先算出常数然后对图初始化</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size; i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= size; j++)&#123;</span><br><span class="line">                 m[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//然后开始dfs画图</span></span><br><span class="line">         <span class="built_in">d</span>(n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//画出图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= size; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= size; j++)&#123;</span><br><span class="line">                 cout&lt;&lt;m[i][j];</span><br><span class="line">             &#125;</span><br><span class="line">             cout&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">d</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;<span class="comment">//如果已经到了第一阶 那就直接画一个x</span></span><br><span class="line">         m[x][y] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//要画第n阶图 我们先画第n-1阶</span></span><br><span class="line">         <span class="type">int</span> size = <span class="built_in">pow</span>(<span class="number">3.0</span>, n<span class="number">-2</span>);<span class="comment">//我们先算出我们求坐标的常数</span></span><br><span class="line">         <span class="built_in">d</span>(n<span class="number">-1</span>, x, y);</span><br><span class="line">         <span class="built_in">d</span>(n<span class="number">-1</span>, x, y<span class="number">+2</span>*size);<span class="comment">//这个是五方的右上角的点</span></span><br><span class="line">         <span class="built_in">d</span>(n<span class="number">-1</span>, x+size, y+size);<span class="comment">//这个是五方的中间点</span></span><br><span class="line">         <span class="built_in">d</span>(n<span class="number">-1</span>, x<span class="number">+2</span>*size, y);<span class="comment">//五方的左下角点</span></span><br><span class="line">         <span class="built_in">d</span>(n<span class="number">-1</span>, x<span class="number">+2</span>*size, y<span class="number">+2</span>*size);<span class="comment">//五方的右下角点</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="案例2-9051–方格填数"><a href="#案例2-9051–方格填数" class="headerlink" title="案例2: 9051–方格填数"></a>案例2: 9051–方格填数</h4><p><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_ccb52d4013-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158362595783.png" alt="企业微信截图_17158362595783.png"> </p>
<p>(本题是一道蓝桥杯填空题没有输入，通过程序跑出答案，赛场上在结束前跑完即可此刻我们要求代码是能在一秒中跑完。)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> in[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">11</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题我们搜索的顺序是按照图的位置来的 从(1,1)这个点向右搜索，然后到头了就跳到下一行的开头 由于我们是刚刚描述的这样顺序搜索所以 右边 下边 右下 左下这四个方向必然是0不用判</span></span><br><span class="line"><span class="comment">这些位置里的填数数字是否相邻</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//定义移动变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//检查这个点是否合法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;<span class="number">3</span>&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span>==<span class="built_in">abs</span>(in[xx][yy]-in[x][y]))&#123;<span class="comment">//如果有这三个方向相邻的数字相邻就不行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//xy是搜索到的点的坐标</span></span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>&amp;&amp;y==<span class="number">3</span>)&#123;<span class="comment">//如果搜到图的终点了就算一次答案 否则不算</span></span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num=<span class="number">0</span>;num&lt;=<span class="number">9</span>;num++)&#123;<span class="comment">//枚举数字  从1枚举到9</span></span><br><span class="line">        <span class="keyword">if</span>(!st[num])&#123;</span><br><span class="line">             st[num]=<span class="number">1</span>;</span><br><span class="line">            in[x][y]=num;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(x,y))&#123;<span class="comment">//如果这个点合法我们就往下搜</span></span><br><span class="line">                <span class="keyword">if</span>(y<span class="number">+1</span>&lt;<span class="number">4</span>)<span class="built_in">dfs</span>(x,y<span class="number">+1</span>);<span class="comment">//如果不是右边边界就往右搜</span></span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">dfs</span>(x<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//否则换到下一行的开头;</span></span><br><span class="line">            &#125;</span><br><span class="line">            st[num]=<span class="number">0</span>;<span class="comment">//回溯恢复现场 让这个字没被访问过 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    in[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">-2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    std::cout&lt;&lt;ans; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/13/%E4%BD%8D%E8%BF%90%E7%AE%97%E9%80%92%E5%BD%92%E5%92%8C%E9%80%92%E6%8E%A8/" data-id="cm23ox8te0001x22zdew35r9s" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第1讲/位运算递归和递推" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/13/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E8%AE%B2/%E4%BD%8D%E8%BF%90%E7%AE%97%E9%80%92%E5%BD%92%E5%92%8C%E9%80%92%E6%8E%A8/" class="article-date">
  <time class="dt-published" datetime="2024-07-13T07:37:46.000Z" itemprop="datePublished">2024-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="位运算知识点介绍："><a href="#位运算知识点介绍：" class="headerlink" title="位运算知识点介绍："></a>位运算知识点介绍：</h3><p>位运算是算法竞赛中的一个常见考点，它涉及到对二进制数位进行操作的一系列技巧和方法。以下是一些在算法竞赛中可能会考察到位运算的方面：</p>
<ol>
<li><strong>基本位运算符的理解与应用</strong>：</li>
</ol>
<p>  - 按位与（&amp;）：对两个数的每一位进行逻辑与操作。</p>
<p>  - 按位或（|）：对两个数的每一位进行逻辑或操作。</p>
<p>  - 按位异或（^）：对两个数的每一位进行异或操作，相同为0，不同为1。</p>
<p>  - 按位取反（~）：对一个数的每一位进行取反操作，0变1，1变0。</p>
<p>  - 左移（&lt;&lt;）：将一个数的所有位向左移动指定的位数。</p>
<p>  - 右移（&gt;&gt;）：将一个数的所有位向右移动指定的位数。</p>
<ol start="2">
<li><strong>位运算的性质和规则</strong>：</li>
</ol>
<p>  - 位运算的优先级。</p>
<p>  - 位运算的结合律和交换律。</p>
<p>  - 位运算在不同数据类型（如int、long long）上的行为。</p>
<ol start="3">
<li><strong>位运算的实际应用</strong>：</li>
</ol>
<p>  - 判断一个数的奇偶性。</p>
<p>  - 交换两个变量的值而不使用额外的存储空间。</p>
<p>  - 计算一个数的二进制表示中1的个数。</p>
<p>  - 判断一个数是否为2的幂次方。</p>
<p>  - 快速幂算法的实现，用于计算大数的幂次方。</p>
<ol start="4">
<li><strong>位运算的优化技巧</strong>：</li>
</ol>
<p>  - 使用位运算进行高效的乘除法运算。</p>
<p>  - 利用位运算优化算法的时间复杂度和空间复杂度。</p>
<ol start="5">
<li><strong>位运算与其他算法的结合</strong>：</li>
</ol>
<p>  - 位运算在动态规划、图论算法、数论算法中的应用。</p>
<p>  - 位运算在解决特定算法问题中的巧妙使用，如处理特定的数据结构或优化搜索过程。</p>
<p>题目a^b</p>
<p>A-  <a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/996/A">a^b_0x01 基本算法-位运算 (nowcoder.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求a的b次方对p取模</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">int</span> b,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;<span class="comment">//要返回的答案，初始化为1是1乘任意数为任意数，不能为0</span></span><br><span class="line">    <span class="keyword">while</span>(b)&#123;<span class="comment">//对b的二进制指数进行枚举</span></span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)&#123; <span class="comment">//b的二进制尾巴是1</span></span><br><span class="line">            ans=(ans*a)%p;</span><br><span class="line">            <span class="comment">//这边主要对指数b进行一个拆分；</span></span><br><span class="line">            <span class="comment">//比如2^10如果直接算要10次</span></span><br><span class="line">            <span class="comment">//我们可以拆分为(2^2)*(2^8)</span></span><br><span class="line">        &#125;</span><br><span class="line">        b=b/<span class="number">2</span>;<span class="comment">//进一步拆分</span></span><br><span class="line">        a=a*a%p;<span class="comment">//我们让a的幂次升高一倍</span></span><br><span class="line">        <span class="comment">//比如a为(2^3) 升高为 (2^6)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a,b,p;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">pow</span>(a%p,b,p)%p;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题目64位整数乘法</p>
<p>龟速乘模板</p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/996/C">C-64位整数乘法_0x01 基本算法-位运算 (nowcoder.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该算法目的就是求大数 a*b%p</span></span><br><span class="line"><span class="comment">因为c++不是python 两个2^64相乘会爆</span></span><br><span class="line"><span class="comment">思想就是 将 b二进制化 从乘法变成加法</span></span><br><span class="line"><span class="comment">比如 求8*6对10取模</span></span><br><span class="line"><span class="comment">可以为 8*2%10+8*4*10</span></span><br><span class="line"><span class="comment">由于我们是循环的进行的 假设8*2%10在上一步中已经求出我们设为a</span></span><br><span class="line"><span class="comment">那8*4%10就可以变为 a*2%10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模乘运算函数，计算 (a * b) % p 的值</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">modMultiply</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 a 和 b 都取模 p，以防止溢出</span></span><br><span class="line">    a %= p;</span><br><span class="line">    b %= p;</span><br><span class="line">    <span class="comment">// 初始化结果为 0</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将 a 乘以 b，并将结果对 p 取模，累加到结果中</span></span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            result = (result + a) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * <span class="number">2</span>) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a, b, p;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">modMultiply</span>(a, b, p);</span><br><span class="line">    cout &lt;&lt;result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种方法的基本思路是将乘法操作分解为一系列的加法和移位操作，同时在每一步中都进行模p运算，以确保数值始终保持在合法范围内。<br>具体来说，算法的步骤如下：</p>
<ol>
<li>将指数b表示为二进制形式，这样可以将其分解为多个2的幂次的和。</li>
<li>初始化结果变量ans为0，用于累加最终的乘积结果。</li>
<li>通过循环遍历指数b的每一位，对于每一位的判断（即b的最低位是否为1），来决定是否将当前的底数a累加到结果ans中，并在每次累加后对ans进行模p运算。</li>
<li>在每次循环中，将底数a左移一位（相当于乘以2），并且同样进行模p运算，以防止a的值过大导致溢出。</li>
<li>同时，将指数b右移一位，继续循环处理下一位，直到b的所有位都被处理完毕。</li>
<li>最终，循环结束后的结果ans即为a乘b对p取模的结果。<br>这种方法的关键在于通过位运算来高效地处理大数乘法，避免了直接计算可能带来的性能问题和溢出风险。通过这种方式，可以快速且准确地计算出64位整数乘法对p取模的结果，这在算法竞赛中是一个非常有用的技巧。</li>
</ol>
<h4 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h4><p>定理1：两数相同异或为0</p>
<p>定理2：如果一个组整数的异或和为0，然后任意某个位置分割开的两个异或和是一样的</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例</span><br><span class="line">假设6个整数位 1 2 3 4 5 1</span><br><span class="line">那任意分成两段他们的异或和都一样  </span><br></pre></td></tr></table></figure>

<p>位运算实例练习</p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给定两个正整数j和k，求有多少个序列满足下列条件：<br>1.序列中的所有元素都在 $ [0,2^{k}-1] $​ 之间。<br>2.它的所有元素的与运算之和为0。<br>3.它的元素或之和是尽可能大的。<br>答案对10^9^+7取模。</p>
<p>输入格式：<br>第一行一个整数t(1≤t≤10)表示数据组数。<br>每组测试数据包含两个整数和k,意义如题面所述。<br>输出格式：<br>对于每组数据，输出符合条件的序列对10^9^十7取模的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*考虑和最大，则每个数的二进制都为 k 位。</span></span><br><span class="line"><span class="comment">考虑所有数 and等于 0，则每一个数在二进制中有且只有一个 0，且这些 0 的所在位数不相同。</span></span><br><span class="line"><span class="comment">因为有 n 个数，有 k 位，所以有 n^k 种方法。</span></span><br><span class="line"><span class="comment">快速幂即可。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">ll t,n,k;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="comment">//快速幂</span></span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">		a=(a*a)%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">qpow</span>(n,k)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我们逐步分析给定的问题条件。假设有一个序列α。</p>
<p>首先，根据第一个条件，序列中的每个元素αi都在0到2的k次方减1的范围内。这意味着每个元素αi可以被表示为一个k位的二进制数。</p>
<p>接着，考虑第二个条件，由于序列中所有元素的按位与运算结果为0，我们可以推断出，在这些二进制表示中，每一位上都必须至少有一个元素是0。</p>
<p>再来看第三个条件，为了使得元素之和最大，同时满足第二个条件，我们需要将二进制位上的0尽可能地转变为1。</p>
<p>综合这三个条件，我们可以发现，在二进制表示中，每一位上可能有不同的情况出现（一个0和若干个1的组合），总共有n种情况。因此，最终的答案就是n。在编写代码时，记得声明long long类型的变量来存储结果</p>
<h4 id="选数异或"><a href="#选数异或" class="headerlink" title="选数异或"></a>选数异或</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240713152830379.png" alt="image-20240713152830379"></h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240713152904863.png" alt="image-20240713152904863"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240713152936439.png" alt="image-20240713152936439"></p>
<h5 id="异或运算性质"><a href="#异或运算性质" class="headerlink" title="异或运算性质"></a>异或运算性质</h5><p>异或运算有一个重要性质：如果 ( a \oplus b &#x3D; x )，那么 ( b &#x3D; x \oplus a )。这意味着一旦确定了 ( a )，( b ) 的值也就确定了。</p>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>题目要求对一个区间 ( [L, R] ) 进行查询，可以使用动态规划（DP）的思想来解决。定义一个数组 ( f )，其中 ( f_i ) 表示在区间 ( [1, i] ) 内所有满足条件的数对的下界的下标的最大值。通过枚举区间内的每个数 ( a )，并计算 ( a \oplus x )，如果 ( a \oplus x ) 在之前出现过，则更新 ( f ) 数组。</p>
<h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><ol>
<li>使用一个哈希表来记录每个数 ( a[i] \oplus x ) 对应的下标。</li>
<li>遍历数组 ( a )，对于每个元素 ( a[i] )，更新 ( f[i] ) 为 ( f[i-1] ) 和 ( Hash[a[i] \oplus x] ) 中的较大值。</li>
<li>对于每个查询区间 ( [l, r] )，判断 ( f[r] ) 是否大于等于 ( l )，如果是，则输出 <code>yes</code>，否则输出 <code>no</code>。</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>],f[<span class="number">100005</span>];</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Hash;<span class="comment">//记录每一个a[i]^x的最近的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    	cin&gt;&gt;a[i];</span><br><span class="line">    	f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],Hash[a[i]^x]);</span><br><span class="line">    	Hash[a[i]]=i;<span class="comment">//哈希一下~</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(f[r]&gt;=l)cout&lt;&lt;<span class="string">&quot;yes\n&quot;</span>;<span class="comment">//左端点在最大下界的左边</span></span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="递推和递归"><a href="#递推和递归" class="headerlink" title="递推和递归"></a>递推和递归</h2><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p><strong>递推</strong>：以问题边界为起点，向原问题正向推导<br><strong>递归</strong>：（有时推导路线难以确定），则将原问题为起点，尝试把状态空间压缩到已知的问题边界，再通过该路线反方向回溯到原问题的方式即递归。</p>
<h4 id="案例1-1621–分形宇宙"><a href="#案例1-1621–分形宇宙" class="headerlink" title="案例1: 1621–分形宇宙"></a>案例1: 1621–分形宇宙</h4><p><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_5ff1dbcf13-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158360726140.png" alt="企业微信截图_17158360726140.png"><br><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_64372d9113-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158361065646.png" alt="企业微信截图_17158361065646.png"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="type">char</span> m[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">d</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">      <span class="type">int</span> n;</span><br><span class="line">      <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">          <span class="type">int</span> size = <span class="built_in">pow</span>(<span class="number">3.0</span>, n<span class="number">-1</span>);<span class="comment">//先算出常数然后对图初始化</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= size; i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= size; j++)&#123;</span><br><span class="line">                 m[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//然后开始dfs画图</span></span><br><span class="line">         <span class="built_in">d</span>(n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//画出图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= size; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= size; j++)&#123;</span><br><span class="line">                 cout&lt;&lt;m[i][j];</span><br><span class="line">             &#125;</span><br><span class="line">             cout&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">d</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;<span class="comment">//如果已经到了第一阶 那就直接画一个x</span></span><br><span class="line">         m[x][y] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//要画第n阶图 我们先画第n-1阶</span></span><br><span class="line">         <span class="type">int</span> size = <span class="built_in">pow</span>(<span class="number">3.0</span>, n<span class="number">-2</span>);<span class="comment">//我们先算出我们求坐标的常数</span></span><br><span class="line">         <span class="built_in">d</span>(n<span class="number">-1</span>, x, y);</span><br><span class="line">         <span class="built_in">d</span>(n<span class="number">-1</span>, x, y<span class="number">+2</span>*size);<span class="comment">//这个是五方的右上角的点</span></span><br><span class="line">         <span class="built_in">d</span>(n<span class="number">-1</span>, x+size, y+size);<span class="comment">//这个是五方的中间点</span></span><br><span class="line">         <span class="built_in">d</span>(n<span class="number">-1</span>, x<span class="number">+2</span>*size, y);<span class="comment">//五方的左下角点</span></span><br><span class="line">         <span class="built_in">d</span>(n<span class="number">-1</span>, x<span class="number">+2</span>*size, y<span class="number">+2</span>*size);<span class="comment">//五方的右下角点</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="案例2-9051–方格填数"><a href="#案例2-9051–方格填数" class="headerlink" title="案例2: 9051–方格填数"></a>案例2: 9051–方格填数</h4><p><img src="https://cdn.acwing.com/media/article/image/2024/05/16/69408_ccb52d4013-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17158362595783.png" alt="企业微信截图_17158362595783.png"> </p>
<p>(本题是一道蓝桥杯填空题没有输入，通过程序跑出答案，赛场上在结束前跑完即可此刻我们要求代码是能在一秒中跑完。)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> in[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">11</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这道题我们搜索的顺序是按照图的位置来的 从(1,1)这个点向右搜索，然后到头了就跳到下一行的开头 由于我们是刚刚描述的这样顺序搜索所以 右边 下边 右下 左下这四个方向必然是0不用判</span></span><br><span class="line"><span class="comment">这些位置里的填数数字是否相邻</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//定义移动变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//检查这个点是否合法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;<span class="number">3</span>&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span>==<span class="built_in">abs</span>(in[xx][yy]-in[x][y]))&#123;<span class="comment">//如果有这三个方向相邻的数字相邻就不行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//xy是搜索到的点的坐标</span></span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>&amp;&amp;y==<span class="number">3</span>)&#123;<span class="comment">//如果搜到图的终点了就算一次答案 否则不算</span></span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num=<span class="number">0</span>;num&lt;=<span class="number">9</span>;num++)&#123;<span class="comment">//枚举数字  从1枚举到9</span></span><br><span class="line">        <span class="keyword">if</span>(!st[num])&#123;</span><br><span class="line">             st[num]=<span class="number">1</span>;</span><br><span class="line">            in[x][y]=num;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(x,y))&#123;<span class="comment">//如果这个点合法我们就往下搜</span></span><br><span class="line">                <span class="keyword">if</span>(y<span class="number">+1</span>&lt;<span class="number">4</span>)<span class="built_in">dfs</span>(x,y<span class="number">+1</span>);<span class="comment">//如果不是右边边界就往右搜</span></span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">dfs</span>(x<span class="number">+1</span>,<span class="number">0</span>);<span class="comment">//否则换到下一行的开头;</span></span><br><span class="line">            &#125;</span><br><span class="line">            st[num]=<span class="number">0</span>;<span class="comment">//回溯恢复现场 让这个字没被访问过 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    in[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">-2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    std::cout&lt;&lt;ans; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/13/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E8%AE%B2/%E4%BD%8D%E8%BF%90%E7%AE%97%E9%80%92%E5%BD%92%E5%92%8C%E9%80%92%E6%8E%A8/" data-id="cm23pcg0v000e362z38f77kjj" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第17讲/数论1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/13/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC17%E8%AE%B2/%E6%95%B0%E8%AE%BA1/" class="article-date">
  <time class="dt-published" datetime="2024-07-12T17:00:38.000Z" itemprop="datePublished">2024-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="费蜀定理"><a href="#费蜀定理" class="headerlink" title="费蜀定理"></a>费蜀定理</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>裴蜀定理，又称贝祖定理（Bézout’s lemma）、贝祖等式（Bézout’s identity）。是一个关于最大公约数的定理。（引用oiwiki）<br>大致内容就是ax+by&#x3D;z  其中x和y是任意整数，那么z必然能够整除gcd(a,b)</p>
<h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><p>首先 a与b皆能够整除gcd(a,b)，不妨设 gcd(a,b)为G,c1&#x3D;a&#x2F;G,c2&#x3D;b&#x2F;G。那么ax+by&#x3D;c1xG+c2yG,那么ax+by&#x3D;(c1x+c2x)G,且c1,x,c2,y均为整数所以z能够整数gcd(a,b)。证毕。</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>$$<br>a^{p-1} \equiv 1 \mod p<br>$$<br>费马小定理用来求除法取余问题<br>由上公式可知 a的逆元为 a^{p-2}也就是a*a^{p-2}&#x3D;1，且由a*(1&#x2F;a)&#x3D;1得(1&#x2F;a) mod p&#x3D;a^{p-2} mod p<br>所以 如果题目里要求 a&#x2F;b模p的值 等价于求a*qmi(b,p-2) mod p  &#x2F;&#x2F;qmi为快速幂函数</p>
<h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>问题：给定整数 a,b，令 d&#x3D;gcd(a,b)，解方程：ax+by&#x3D;d。</p>
<p>先从 gcd 入手，我们知道gcd(a, b) &#x3D; gcd(b, a \mod b) ，那么显然 ( ar + by &#x3D; ba + (a % b)y &#x3D; d )。<br>假设我们求解出了方程<br>$$<br>b \cdot x + (a % b) \cdot y &#x3D; d<br>$$<br>的一组解：x &#x3D; x_0, y &#x3D; y_0 ，那么原方程的解与  x_0, y_0  关系是怎么样的<br>推导如下<br>$$<br>\begin{align*}<br>d &amp;&#x3D; ba_0 + (a % b) y_0, \<br>d &amp;&#x3D; bz_0 + (a - L \cdot b) g_0, \<br>d &amp;&#x3D; ba_0 + ay_0 - L \cdot b \cdot y_0, \<br>d &amp;&#x3D; a_0 + b(z_0 - L \cdot y_0).<br>\end{align*}<br>$$<br>我们再把上面这个式子  ax + by &#x3D; d  进行比对，发现原方程的一组特解就是。<br>$$<br>x &#x3D; y_0, \quad y &#x3D; z_0 - L \cdot y_0<br>$$<br>模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void exgcd(int a,int b,int &amp;x,int &amp;y)&#123;</span><br><span class="line">    if(b==0)&#123;</span><br><span class="line">        x=1;</span><br><span class="line">        y=0;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b,a%b,x,y);</span><br><span class="line">    int t=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=t-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        int a, b, m, x, y;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; m;</span><br><span class="line">        int d = exgcd(a, m, x, y);</span><br><span class="line">        if(b % d == 0)&#123;</span><br><span class="line">            cout &lt;&lt; (long long)x * b / d % m&lt;&lt; endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><h2 id="中国剩余定理的应用"><a href="#中国剩余定理的应用" class="headerlink" title="中国剩余定理的应用"></a>中国剩余定理的应用</h2><p>$$<br>\begin{align*}<br>&amp;\text{有 } n \text{ 个方程 } x \equiv a_i \mod b_i, \<br>&amp;\text{其中 } i &#x3D; 1, 2, \ldots, n, \<br>&amp;\text{前 } k-1 \text{ 个方程的最小正整数解是 } ans_{k-1}, \<br>&amp;\text{令 } M &#x3D; \text{lcm}(b_1, b_2, \ldots, b_{k-1}), \<br>&amp;\text{设 } ans_{k} &#x3D; ans_{k-1} + Mx, \text{ 其中 } x \text{ 为整数}, \<br>&amp;ans_{k-1}+ xM \equiv a_k \mod b_k, \<br>&amp;Mx \equiv a_k - ans_{k-1} \mod b_k, \<br>&amp;Mx + b_ky \equiv a_k - ans_{k-1}.<br>\end{align*}<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">int n;</span><br><span class="line">LL ans,M=1; </span><br><span class="line">LL gcd(LL x,LL y)&#123; return y?gcd(y,x%y):x; &#125; </span><br><span class="line">LL lcm(LL x,LL y)&#123; return x*y/gcd(x,y); &#125;</span><br><span class="line">LL exgcd(LL A,LL B,LL &amp;x,LL &amp;y)&#123;</span><br><span class="line">    if(!B)&#123; x=1,y=0;return x; &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        LL d=exgcd(B,A%B,y,x);</span><br><span class="line">        y-=A/B*x;return d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">void crt(LL A,LL B)&#123;</span><br><span class="line">    LL a=M,b=B,c=((A-ans)%B+B)%B,x,y;</span><br><span class="line">    LL g=exgcd(a,b,x,y);</span><br><span class="line">    if(c%g) return;</span><br><span class="line">    x=((x*(c/g))%B+B)%B;ans+=x*M;</span><br><span class="line">    M=lcm(M,B);ans=(ans%M+M)%M;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    LL a,b;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b),crt(b,a);</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="同余最短路"><a href="#同余最短路" class="headerlink" title="同余最短路"></a>同余最短路</h3><h4 id="同余最短路问题描述："><a href="#同余最短路问题描述：" class="headerlink" title="同余最短路问题描述："></a>同余最短路问题描述：</h4><p>同余最短路算法用于解决这样的问题：给定一组整数 ( n ) 个，每个整数可以重复使用任意多次，我们需要确定使用这些整数可以拼凑出哪些数，尤其是关注在某个给定范围 ( [l, r] ) 内能拼凑出的数的个数。</p>
<h4 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h4><p>算法的核心思想是基于同余理论。考虑模 ( A_1 ) 的每个同余类 ( [x] )，如果使用整数集 $A_2, A_3, \ldots, A_n  $可以凑出一个同余类 ( [x] ) 中的某个数 ( x )，那么可以不断加 ( A_1 ) 来凑出 ( [x] ) 中所有大于等于 ( x ) 的数。</p>
<h4 id="构建图模型："><a href="#构建图模型：" class="headerlink" title="构建图模型："></a>构建图模型：</h4><p>将问题转化为图论问题，对于模 ( A_1 ) 的每个同余类，我们构建一个节点，并且对于 ( i &#x3D; 2 ) 到 ( n ) 的每个整数 ( A_i )，我们在 ( [x] ) 加 ( A_i ) 后得到的同余类节点之间连一条边，边权为 ( A_i )。这样，每个同余类中能被凑出的最小数就是从 ( [0] ) 到该同余类的最短路径长度。</p>
<h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><ol>
<li>对于模 $A_1 $ 的每个同余类  [x] ，创建一个节点。</li>
<li>对于每个 $ A_i (i&#x3D;2,3,\ldots,n) $，从 ( [x] ) 节点到 $ [(x + A_i) \mod A_1] $节点连一条边，边权为 ( A_i )。</li>
<li>运行单源最短路算法（如 Dijkstra 算法）从 ( [0] ) 节点开始，计算到每个同余类 ( [x] ) 的最短路径长度。</li>
<li>根据最短路径长度计算在给定范围 ( [l, r] ) 内能拼凑出的数的个数。</li>
</ol>
<h4 id="算法复杂度："><a href="#算法复杂度：" class="headerlink" title="算法复杂度："></a>算法复杂度：</h4><p>算法的复杂度取决于所使用的最短路算法。如果使用优先队列版的 Dijkstra 算法，复杂度为 $O(nA_1 + n\log(nA_1)) $，其中 ( A_1 ) 是模数，( n ) 是整数个数。</p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A[<span class="number">1</span>]; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; ++j)</span><br><span class="line">        G[i].<span class="built_in">emplace_back</span>((i + A[j]) % A[<span class="number">1</span>], A[j]);</span><br><span class="line"><span class="comment">// 跑单源最短路</span></span><br><span class="line">ll R = <span class="number">0</span>, L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A[<span class="number">1</span>]; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dis[i] != INF &amp;&amp; dis[i] &lt;= r) R += (r - dis[i]) / A[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dis[i] != INF &amp;&amp; dis[i] &lt;= l - <span class="number">1</span>) L += (l - <span class="number">1</span> - dis[i]) / A[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; R - L &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="应用示例："><a href="#应用示例：" class="headerlink" title="应用示例："></a>应用示例：</h4><p>例如，对于整数集合 $ A &#x3D; {5, 7, 11} $,我们可以构建一个图，其中 ( [0] ) 到 ( [3] ) 的最短路径是 $ [0] \xrightarrow{7} [2] \xrightarrow{11} [3] $，最短路径长度为 18。这意味着在模 5 的同余类 ( [3] ) 中，大于等于 18 的所有数都可以被凑出来。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>同余最短路是一种将拼凑整数问题转化为图论问题的算法，通过构建一个特殊的图并应用最短路算法来解决问题。这种方法提供了一种与询问值域无关的解决方案，从而在某些情况下可以显著提高效率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/13/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC17%E8%AE%B2/%E6%95%B0%E8%AE%BA1/" data-id="cm23pcg0u000b362zgdewh1bo" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-课编程/第12讲/负环和差分约束" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/13/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC12%E8%AE%B2/%E8%B4%9F%E7%8E%AF%E5%92%8C%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/" class="article-date">
  <time class="dt-published" datetime="2024-07-12T16:55:36.000Z" itemprop="datePublished">2024-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="负环"><a href="#负环" class="headerlink" title="负环"></a>负环</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>给定一张有向图（在无向图中，每条边可以被视为两个方向相反的有向边，因此无向图可以按照有向图来处理），图中的每条边都分配有一个权重（或称为长度）。如果某条边的权重是负数，那么这条边被称为负权边。此外，如果图中存在一个闭合的环路，且该环路上所有边的权重之和为负数，则这个环路被称为“负环”。</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240525102938036.png" alt="image-20240525102938036"></p>
<p>如果图中存在负环，那么它会导致一些直观的表现：无论经过多少次迭代，总能找到一条有向边 ((x, y, z))，使得从 (y) 到 (x) 的已知最短距离 (dist[y]) 大于从 (x) 出发经过这条边到达 (y) 的距离 (dist[x] + z)。这意味着，使用像Bellman-Ford或SPFA这样的算法时，它们将永远无法结束，因为每次迭代都会发现新的更短路径。</p>
<p>根据抽屉原理，如果存在一个 (dist[x])，表示从起点1到节点 (x) 的最短路径包含至少 (n) 条边，那么这条路径必然在某处重复经过某个节点 (P)。换句话说，这条最短路径上存在一个环，在这个环上的每个节点 (P) 都能更新下一个节点的 (dist) 值。如果绕这个环转一圈，最终能够更新环上节点 (P) 自己的 (dist) 值。因此，这个环的总长度必须是负数。每绕这个环一圈，最短路径的长度就会变得更小，这意味着路径长度永远不会稳定，也不可能达到一个状态，使得每条边都满足三角形不等式。</p>
<p>基于这个结论，我们可以得出以下的判定法则：如果一个图中存在负环，那么从某个节点到它自己的最短路径永远不会收敛，因为存在一个可以通过不断绕环来不断缩短的路径。这个特性可以用来检测图中是否存在负环，因为如果最短路径算法无法在有限步内完成，这通常意味着图中存在负环。</p>
<p>在图论中，判断负环的存在性对于确定图的某些性质非常重要。</p>
<p>以下是对&#x3D;&#x3D;<strong>SPFA（Shortest Path Faster Algorithm）判定负环</strong>&#x3D;&#x3D;的方法的重新阐述：</p>
<ol>
<li><p>在图论中，判断负环的存在性对于确定图的某些性质非常重要。以下是对SPFA（Shortest Path Faster Algorithm）判定负环的方法的重新阐述：</p>
<ol>
<li><p><strong>定义边数计数</strong>：我们定义一个数组 <code>cnt[x]</code> 来表示从起点 1 到节点 x 的最短路径上包含的边的数目。初始化时，<code>cnt[1]</code> 设置为 0，因为从起点到它自己的最短路径不包含任何边。</p>
</li>
<li><p><strong>更新边数</strong>：当执行距离更新操作 <code>dist[y] = dist[x] + z</code> 时，同时更新 <code>cnt[y] = cnt[x] + 1</code>，其中 <code>z</code> 是边的权重。</p>
</li>
<li><p><strong>检测负环</strong>：如果在更新过程中发现 <code>cnt[y]</code> 大于等于图中顶点的数量 <code>n</code>，即 <code>cnt[y] ≥ n</code>，这表明存在一个包含至少 <code>n</code> 条边的循环路径，这意味着图中存在负环。</p>
</li>
<li><p><strong>算法结束</strong>：如果算法能够正常结束，即所有顶点的距离更新完成后没有发现 <code>cnt[y] ≥ n</code> 的情况，那么图中不存在负环。</p>
</li>
<li><p><strong>时间复杂度</strong>：Bellman-Ford算法判定负环的时间复杂度是 O(nm)，其中 <code>n</code> 是顶点数，<code>m</code> 是边数。SPFA算法在判定负环方面通常更快，但在最坏情况下，其时间复杂度也可能达到 O(nm)。</p>
</li>
<li><p><strong>其他判定方法</strong>：除了上述方法，还可以通过记录每个顶点入队的次数来判定负环。如果一个顶点的入队次数达到 <code>n</code>，则表明存在负环。然而，这种方法的效率通常不如基于边数计数的方法高。</p>
</li>
<li><p><strong>同时使用判定方法</strong>：尽管如此，读者可以同时使用这两种方法来提高判定负环的准确性。</p>
</li>
<li><p><strong>设置上界</strong>：在某些情况下，可以根据运行时间限制，为队列的总长度（所有顶点的入队总次数）设置一个上限。如果超出这个上限，可以直接判定存在负环，从而避免算法超时。但这种方法可能会导致错误的判定。</p>
</li>
<li><p><strong>优化手段</strong>：还有其他的优化手段，比如将SPFA的队列替换为栈，或者将基于广度优先搜索（BFS）的SPFA改为基于深度优先搜索（DFS）。这些优化手段在负环存在时可能提高程序运行效率，但在负环不存在时可能会降低计算最短路径的效率。</p>
</li>
<li><p><strong>谨慎使用</strong>：因此，读者在使用这些优化手段时应该谨慎，根据具体情况和需求来选择最合适的方法。</p>
</li>
</ol>
</li>
</ol>
<h4 id="spfa判断负环模板"><a href="#spfa判断负环模板" class="headerlink" title="spfa判断负环模板"></a>spfa判断负环模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,M=<span class="number">6000</span>;</span><br><span class="line"><span class="type">int</span> n,m,w;</span><br><span class="line"><span class="type">int</span> ne[M],h[N],e[M],W[M],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    W[++idx]=c,ne[idx]=h[a],e[idx]=b,h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt[M],dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">   </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)q.<span class="built_in">push</span>(i),st[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> zz=q.<span class="built_in">front</span>();</span><br><span class="line">      <span class="comment">// cout&lt;&lt;zz&lt;&lt;endl;</span></span><br><span class="line">        st[zz]=<span class="literal">false</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[zz];i;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> cc=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[cc]&gt;dist[zz]+W[i])&#123;</span><br><span class="line">                dist[cc]=dist[zz]+W[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[cc])&#123; </span><br><span class="line">                    q.<span class="built_in">push</span>(cc);</span><br><span class="line">                    st[cc]=<span class="number">1</span>;</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">                cnt[cc]=cnt[zz]<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[cc]&gt;=n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;w;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,-c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录一个点经过n次才判负环是否有点太慢太蠢，这边介绍一个通关栈的方法一个Spfa+计数器这个做法里，我们不仅计数，到一定次数后，遍历父节点直接检测是否存在环，保证了解法的正确性。，要比上面的方法要快30倍的优化 提前判环法。</p>
<h4 id="优化模板"><a href="#优化模板" class="headerlink" title="优化模板"></a>优化模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//using ll = long long;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n,m,w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bspfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> PII=std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line">    std::cin&gt;&gt;n&gt;&gt;m&gt;&gt;w;</span><br><span class="line">    std::vector&lt;std::vector&lt;PII&gt;&gt;<span class="built_in">G</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        G[a].<span class="built_in">emplace_back</span>(b,c);</span><br><span class="line">        G[b].<span class="built_in">emplace_back</span>(a,c);</span><br><span class="line">    &#125;<span class="keyword">while</span>(w--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        G[a].<span class="built_in">emplace_back</span>(b,-c);</span><br><span class="line">        <span class="comment">//G[b].emplace_back(a,c);</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;<span class="built_in">dist</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;<span class="built_in">pre</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">st</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)q.<span class="built_in">emplace</span>(i),st[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dfs=[&amp;]()</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">        std::vector&lt;<span class="type">bool</span>&gt;<span class="built_in">instack</span>(n,<span class="literal">false</span>),<span class="built_in">vis</span>(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i; j; j=pre[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        vis[j]=<span class="literal">true</span>;</span><br><span class="line">                        vec.<span class="built_in">push_back</span>(j);</span><br><span class="line">                        instack[j]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(instack[j])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j:vec)instack[j]=<span class="literal">false</span>;</span><br><span class="line">                vec.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:G[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[u]+w&lt;dist[v])&#123;</span><br><span class="line">                pre[v]=u;</span><br><span class="line">                dist[v]=dist[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(++idx==n)&#123;</span><br><span class="line">                    idx=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">dfs</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!st[v])&#123;</span><br><span class="line">                    st[v]=<span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">dfs</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> _;</span><br><span class="line">    std::ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    std::cin&gt;&gt;_;</span><br><span class="line">    <span class="keyword">while</span>(_--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Bspfa</span>())std::cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><p>差分约束系统是一种特殊的数学结构，它由多个变量和一系列的不等式构成。这些不等式是一次的，并且涉及变量之间的差。</p>
<img src="https://picx.zhimg.com/v2-3bba024ff266b82117e593fecf1c69ad_720w.png?source=d16d100b" alt="算法学习笔记(11): 差分约束" style="zoom:50%;" align='left'/>

<img src=C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240525115335320.png alt="算法学习笔记(11): 差分约束" style="zoom:100%;" align='left'/>

<p>差分约束就是对上面这样的一组多元不等式(每一个y都是已知量)</p>
<p>形如$$x_1-x_2\leq c$$，可以通过化简得到 $$x_1\leq x_2+c$$。</p>
<p>以下是对差分约束系统的重新阐述：</p>
<ol>
<li><strong>系统构成</strong>：一个差分约束系统包含 N 个变量 $和 M$个约束条件。每个约束条件形如 $$X_i - X_j \leq c_k$$，其中 $$c_k$$ 是一个常数，$$1 \leq i, j \leq N$$，$$1 \leq k \leq M$$。</li>
<li><strong>求解问题</strong>：目标是找到一组特定的值 $$a_1, a_2, \ldots, a_N$$ 赋给变量 $$X_1, X_2, \ldots, X_N$$，使得所有约束条件都得到满足。</li>
<li><strong>约束条件变换</strong>：每个约束 $$X_i - X_j \leq c_k$$可以变换为 $$X_i \leq X_j + c_k$$，这与单源最短路径问题中的三角形不等式 $$d[y] \leq d[x] + z$$非常相似。</li>
<li><strong>图的构建</strong>：可以把每个变量 $$X_i$$ 看作图中的一个节点 i。对于每个约束 $$X_i - X_j \leq c_k$$，可以在节点 j 向节点 i 连一条长度为 $$c_k$$ 的有向边。</li>
<li><strong>解的通用性</strong>：如果集合 $${a_1, a_2, \ldots, a_N}$$ 是一组解，那么对任意常数 A，集合 $${a_1 + A, \ldots, a_N + A}$$ 也是一组解，因为作差后 (A) 会被消掉。</li>
<li><strong>求负数解</strong>：可以先求一组负数解，即假设 $$X_i \leq 0$$，然后引入一个额外的节点 0，令 $$X_0 &#x3D; 0$$，从而增加 N 个形如 $$X_i - X_0 \leq 0$$ 的约束条件，即从节点 0 向每个节点 (i) 连一条长度为 0 的有向边。</li>
<li><strong>单源最短路</strong>：设置 (d[0] &#x3D; 0)，以节点 0 为起点计算单源最短路径。如果图中存在负环，则给定的差分约束系统无解。</li>
<li><strong>解的确定</strong>：如果图中不存在负环，那么$$X_i &#x3D; d[i]$$ 就是差分约束系统的一组解。</li>
<li><strong>不等式方向变换</strong>：在某些情况下，约束条件可能形如 $$X_i - X_j \geq c_k$$。这时，可以连接从 j 到 i 的长度为 $$c_k$$ 的有向边，并计算单源最长路径。如果图中存在正环，则系统无解。</li>
<li><strong>约束条件转换</strong>：也可以将约束条件 $$X_i - X_j \geq c_k$$ 转换为 $$X_j - X_i \leq -c_k$$，然后按照单源最短路径问题进行计算。</li>
</ol>
<p>通过上述方法，我们可以将差分约束系统的问题转化为图论中的最短路径问题，从而利用图算法来寻找解决方案。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>模板题</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240529021827059.png" alt="image-20240529021827059"></h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240529021906702.png" alt="image-20240529021906702"></p>
<p><strong>输入</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">2 3 -2</span><br><span class="line">1 3 1</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 3 5</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240529022150872.png" alt="image-20240529022150872"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">作者：Pecco</span><br><span class="line">链接：https:<span class="comment">//zhuanlan.zhihu.com/p/104764488</span></span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXM 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, sgn = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            sgn *= <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * sgn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt_edge, head[MAXN];</span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, next, w;</span><br><span class="line">&#125; edges[MAXM];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges[++cnt_edge].next = head[from];</span><br><span class="line">    edges[cnt_edge].to = to;</span><br><span class="line">    edges[cnt_edge].w = w;</span><br><span class="line">    head[from] = cnt_edge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> inqueue[MAXN];</span><br><span class="line"><span class="type">int</span> cnt[MAXN], dis[MAXN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">127</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line"><span class="comment">//  memset(dis, -127, sizeof(dis));</span></span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = Q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (cnt[p] &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        inqueue[p] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> eg = head[p]; eg != <span class="number">0</span>; eg = edges[eg].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> to = edges[eg].to;</span><br><span class="line">            <span class="keyword">if</span> (edges[eg].w + dis[p] &lt; dis[to])</span><br><span class="line"><span class="comment">//          if (edges[eg].w + dis[p] &gt; dis[to])</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = edges[eg].w + dis[p];</span><br><span class="line">                <span class="keyword">if</span> (!inqueue[to])</span><br><span class="line">                &#123;</span><br><span class="line">                    Q.<span class="built_in">push</span>(to);</span><br><span class="line">                    inqueue[to] = <span class="literal">true</span>;</span><br><span class="line">                    cnt[to]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), w = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(y, x, w);</span><br><span class="line"><span class="comment">//      add_edge(x, y, -w);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">add_edge</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SPFA</span>(<span class="number">0</span>, n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了SPFA判负环，如果存在<strong>负环</strong>，最短路无解，则原不等式组也无解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/13/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC12%E8%AE%B2/%E8%B4%9F%E7%8E%AF%E5%92%8C%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/" data-id="cm23pcg0t0003362z0tbcgx9a" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E8%AE%B2/%E8%B4%AA%E5%BF%83%E8%A7%A3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC6%E8%AE%B2/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC7%E8%AE%B2/%E7%BA%BF%E6%AE%B5%E6%A0%91/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
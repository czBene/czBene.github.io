<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="有向图的存储方式在讨论图的存储方式时，我们通常会遇到两种基本的数据结构：邻接矩阵和邻接表。这些存储方式可以应用于有向图和无向图。 有向图对于有向图，我们可以用一个集合 V 表示图中的顶点，用一个集合 E 表示图中的边。在有向图中，一条边 (x, y) 表示从顶点 x 到顶点 y 的有向边，其边权（或长度）表示为 w(x, y)。 邻接矩阵对于一个有 n 个顶点的图，邻接矩阵 A 是一个 n×n 的">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2024/05/25/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC11%E8%AE%B2/%E6%9C%80%E7%9F%AD%E8%B7%AF/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="有向图的存储方式在讨论图的存储方式时，我们通常会遇到两种基本的数据结构：邻接矩阵和邻接表。这些存储方式可以应用于有向图和无向图。 有向图对于有向图，我们可以用一个集合 V 表示图中的顶点，用一个集合 E 表示图中的边。在有向图中，一条边 (x, y) 表示从顶点 x 到顶点 y 的有向边，其边权（或长度）表示为 w(x, y)。 邻接矩阵对于一个有 n 个顶点的图，邻接矩阵 A 是一个 n×n 的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.acwing.com/media/article/image/2022/04/25/69408_e568177ac4-7E4B2A658C39478F1BDFF05F63405093.png">
<meta property="article:published_time" content="2024-05-24T17:35:44.000Z">
<meta property="article:modified_time" content="2024-05-24T17:35:44.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.acwing.com/media/article/image/2022/04/25/69408_e568177ac4-7E4B2A658C39478F1BDFF05F63405093.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-课编程/第11讲/最短路" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/25/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC11%E8%AE%B2/%E6%9C%80%E7%9F%AD%E8%B7%AF/" class="article-date">
  <time class="dt-published" datetime="2024-05-24T17:35:44.000Z" itemprop="datePublished">2024-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="有向图的存储方式"><a href="#有向图的存储方式" class="headerlink" title="有向图的存储方式"></a>有向图的存储方式</h2><p>在讨论图的存储方式时，我们通常会遇到两种基本的数据结构：<strong>邻接矩阵</strong>和<strong>邻接表</strong>。这些存储方式可以应用于<strong>有向图</strong>和<strong>无向图</strong>。</p>
<h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><p>对于有向图，我们可以用一个集合 V 表示图中的顶点，用一个集合 E 表示图中的边。在有向图中，一条边 (x, y) 表示从顶点 x 到顶点 y 的有向边，其边权（或长度）表示为 w(x, y)。</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>对于一个有 n 个顶点的图，邻接矩阵 A 是一个 n×n 的矩阵。在这个矩阵中，如果顶点 i 到顶点 j 有一条边，则 A[i]</p>
<p>[j] 存储边的权重 w(i, j)；如果没有直接的边，则 A[i][j] 为无穷大（或一个非常大的数，表示不可达）。邻接矩阵的空间复杂度为 O(n^2^)，因为它需要存储一个 n×n 的矩阵。</p>
<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><p>邻接表是一种更节省空间的方式来存储图，特别是对于稀疏图。它使用一个数组（表头数组）来记录每个顶点的邻接点信息。数组 head 的长度为 n，其中 head[i] 存储了从顶点 i 出发的第一条边的信息。边的信息通常由两个数组来记录：一个数组 ver 记录每条边的终点，另一个数组 edge 记录每条边的权重。这样，对于每个顶点，我们只需要存储与它直接相连的边的信息，而不是整个 n×n 矩阵。</p>
<h4 id="无向图的存储方式"><a href="#无向图的存储方式" class="headerlink" title="无向图的存储方式"></a>无向图的存储方式</h4><p>对于<strong>无向图</strong>，每条边可以看作是两条方向相反的有向边，因此无向图也可以使用上述的存储方式。在邻接矩阵中，如果 (x, y) 是一条边，则 A[i][j] 和 A[j][i] 都为该边的权重。在邻接表中，每条边的信息会被存储两次，一次是从 x 到 y，另一次是从 y 到 x。</p>
<h4 id="存图代码模板"><a href="#存图代码模板" class="headerlink" title="存图代码模板"></a>存图代码模板</h4><p>通过这两种存储方式，我们可以有效地表示和操作图中的边和顶点，进而解决如<strong>最短路径</strong>等图论问题。</p>
<p>下面介绍一种通过链式前向星来达到存放邻接表的效果。</p>
<p><img src="https://cdn.acwing.com/media/article/image/2022/04/25/69408_e568177ac4-7E4B2A658C39478F1BDFF05F63405093.png" alt="7E4B2A658C39478F1BDFF05F63405093.png"></p>
<p>上图是先idx++(idx是从0开始)的模板，下文给出具体的模板是++idx，让idx从1开始，这样判有没有找到看是否为0就可以。</p>
<p><strong>添加路径代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> h[<span class="number">1000</span>],w[<span class="number">1000000</span>],ne[<span class="number">1000000</span>],e[<span class="number">1000000</span>];<span class="comment">//表头 路径权值，下一个地址，标记这个是哪个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line"> w[++idx]=c,e[idx]=b,ne[idx]=h[a],h[a]=idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=ne[i])&#123;</span><br><span class="line">    <span class="type">int</span> y=e[i],z=w[i];</span><br><span class="line">    <span class="comment">//找到一条x指向y的边，权值是z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><h3 id="Dijikstra算法"><a href="#Dijikstra算法" class="headerlink" title="Dijikstra算法"></a>Dijikstra算法</h3><p>Dijkstra算法是一种用于在加权图中寻找单个源点到所有其他顶点的最短路径的算法。它基于贪心选择性质，仅适用于边的权重为非负的图。以下是对Dijkstra算法流程的重新阐述：</p>
<ol>
<li><p><strong>初始化</strong>：设置源点到自身的距离为0，即 <code>dist[源点] = 0</code>，而源点到其他所有顶点的距离初始化为正无穷大，即 <code>dist[v] = ∞</code> 对于所有 <code>v ≠ 源点</code>。</p>
</li>
<li><p><strong>寻找最小距离节点</strong>：从未标记的节点中选择一个距离源点最近的节点 <code>x</code>，并将其标记为已处理。</p>
</li>
<li><p><strong>更新相邻节点距离</strong>：遍历节点 <code>x</code> 的所有邻接点 <code>y</code>，如果通过节点 <code>x</code> 到达 <code>y</code> 的距离小于当前已知的距离 <code>dist[y]</code>，即 <code>dist[x] + 边的权重 &lt; dist[y]</code>，则更新 <code>dist[y] = dist[x] + 边的权重</code>。</p>
</li>
<li><p><strong>重复过程</strong>：重复步骤2和3，直到所有顶点都被标记为已处理。</p>
</li>
</ol>
<p>Dijkstra算法的核心思想是，如果边的权重都是非负数，那么一旦某个节点被标记为已处理，那么从源点到该节点的最短路径长度就不会被后续的更新所改变。这是因为最短路径不可能通过一个更远的节点来变得更短。通过不断选择当前未处理的节点中距离最小的节点，并更新它的邻接节点的距离，最终可以确定从源点到图中所有顶点的最短路径长度。</p>
<h4 id="堆优化"><a href="#堆优化" class="headerlink" title="&#x3D;&#x3D;堆优化&#x3D;&#x3D;"></a>&#x3D;&#x3D;堆优化&#x3D;&#x3D;</h4><p>在原始的Dijkstra算法实现中，算法的总体时间复杂度为O(n^2^),这主要是因为在每一步中寻找距离最小的未标记节点时需要对所有未处理的节点进行遍历，这一过程在最坏情况下需要 O(n) 的时间，而整个算法需要重复 n 次这样的操作。</p>
<p>优化后的算法中，寻找全局最小值的操作可以在 O(log n) 的时间内完成，因为二叉堆允许我们快速地从所有顶点中提取出具有最小距离值的顶点。对于每个顶点，我们都需要从堆中删除它，这同样可以在 O(log n) 的时间内完成。此外，对于每条边的扩展和更新操作，也可以在 O(log n) 的时间内完成，因为需要将更新后的顶点重新插入到堆中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">510</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> mp[N][N];<span class="comment">//图标</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">//dist[i]表示起始点到i的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">//判断一个点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是链式前向星的模板</span></span><br><span class="line"><span class="type">int</span> h[N],w[<span class="number">100</span>*N],ne[<span class="number">100</span>*N],e[<span class="number">100</span>*N],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">     w[++idx]=c,e[idx]=b,ne[idx]=h[a],h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">priority_queue&lt;PII&gt;q;<span class="comment">//默认是大根堆，以q.first排序，可以利用相反数变成小根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//取出堆顶</span></span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().y;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[x])<span class="keyword">continue</span>;<span class="comment">//如果这个点标记过就不要运行了</span></span><br><span class="line">        st[x]=<span class="number">1</span>;<span class="comment">//否则就让这个点上标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> y=e[i],z=w[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[y]&gt;dist[x]+z)&#123;</span><br><span class="line">                dist[y]=dist[x]+z;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;-dist[y],y&#125;);<span class="comment">//存入队列里，前面说了第一个存的是距离的相反数，后面是这个点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;<span class="comment">//存边 存a-b，权值为c的无向边</span></span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h3><p>前提讲一下<strong>bellman_ford算法</strong>，<strong>SPFA算法</strong>仅仅只是对该算法的一个优化。</p>
<h4 id="bellman-ford算法"><a href="#bellman-ford算法" class="headerlink" title="bellman_ford算法"></a>bellman_ford算法</h4><h5 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h5><h6 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h6><p>Bellman-Ford算法用于计算图中从单一源点到所有其他顶点的最短路径。它能够处理负权边，但不能处理负权回路。</p>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>, M=<span class="number">10010</span>;</span><br><span class="line"><span class="comment">//链式前向星</span></span><br><span class="line"><span class="type">int</span> h[N],w[<span class="number">100</span>*N],ne[<span class="number">100</span>*N],e[<span class="number">100</span>*N],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">     w[++idx]=c,e[idx]=b,ne[idx]=h[a],h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> back[N]; <span class="comment">// 备份数组，防止更新时的串联问题</span></span><br><span class="line"><span class="type">int</span> n, m, k; <span class="comment">// k代表最短路径最多包含k条边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// 初始化距离为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 源点到自己的距离为0</span></span><br><span class="line">    k=<span class="number">1000</span>;<span class="comment">//给k设值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">// k次循环</span></span><br><span class="line">        <span class="built_in">memcpy</span>(back, dist, <span class="keyword">sizeof</span> dist); <span class="comment">// 备份当前的dist数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=n;a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=h[a];j;j=ne[j])&#123;</span><br><span class="line">                <span class="type">int</span> b=e[j],z=w[j];</span><br><span class="line">                dist[b]=<span class="built_in">min</span>(dist[b],back[a]+z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 检查是否存在负权回路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n]; <span class="comment">// 返回最短路径长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        <span class="built_in">add</span>(a,b,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;dist[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明</p>
<ol>
<li>初始化：所有点到源点的距离初始化为无穷大，源点到自己的距离为0。</li>
<li>循环遍历：进行k次循环，每次循环遍历所有边。</li>
<li>边的更新：使用备份数组<code>back</code>防止更新时的串联问题。</li>
<li>检查负权回路：如果存在负权回路，返回-1。</li>
<li>返回结果：返回从源点到终点的最短路径长度。</li>
</ol>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><ul>
<li>Bellman-Ford算法可以处理负权边，但不能处理负权回路。</li>
<li>SPFA算法在大多数情况下效率更高，但在限制最短路径边的数量时，Bellman-Ford算法更适用。</li>
</ul>
<p>&#x3D;&#x3D;<strong>SPFA算法，</strong>&#x3D;&#x3D;国际上通常称为“队列优化的Bellman-Ford算法”，在中国大陆地区有时被称为SPA算法。这个算法是基于Bellman-Ford算法的优化版本，它通过使用队列来提高效率，特别是在稀疏图上。以下是SPFA算法的流程描述：</p>
<ol>
<li><p><strong>初始化队列</strong>：创建一个队列，开始时队列中只包含起点，通常设为节点1。</p>
</li>
<li><p><strong>队列操作</strong>：从队列中取出一个节点（称为队头节点），检查该节点的所有出边（邻接边），对于每条边<code>(x, y, z)</code>：</p>
<ul>
<li>如果节点<code>y</code>的当前最短路径长度<code>dist[y]</code>大于节点<code>x</code>的最短路径长度加上边的权重<code>z</code>（即<code>dist[y] &gt; dist[x] + z</code>），</li>
<li>则使用<code>dist[x] + z</code>来更新节点<code>y</code>的最短路径长度<code>dist[y]</code>。</li>
<li>如果节点<code>y</code>不在队列中，则将节点<code>y</code>加入队列。</li>
</ul>
</li>
<li><p><strong>重复过程</strong>：重复上述步骤，直到队列为空。</p>
</li>
</ol>
<p>在算法的每一步，队列中保存的是待扩展的节点。每次将节点加入队列，相当于完成了一次对<code>dist</code>数组的更新，使得它满足三角形不等式。一个节点可能会多次进出队列。最终，图中的所有节点将收敛到一个状态，即它们都满足三角形不等式。</p>
<p>SPFA算法的优势在于它避免了Bellman-Ford算法中对不需要扩展的节点的冗余扫描，因此在稀疏图上运行效率较高，可以达到O(k)级别，其中k是一个较小的常数。然而，在稠密图或特殊构造的网格图上，SPFA算法的性能可能会退化，变成O(nm)的复杂度。</p>
<p>简而言之，SPFA算法是Bellman-Ford算法的一种优化，通过使用队列来减少不必要的计算，提高在稀疏图上的效率，但在某些情况下可能仍然会遇到性能问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;<span class="comment">//到源点的距离，下标号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N],w[N],ne[N],idx=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">//各点到源点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++idx]=b;w[idx]=c;ne[idx]=h[a];h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        PII p=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> t=p.se;</span><br><span class="line">        st[t]=<span class="literal">false</span>;<span class="comment">//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])&#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;<span class="comment">//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(res==<span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多源汇最短路问题-具有多个源点"><a href="#多源汇最短路问题-具有多个源点" class="headerlink" title="多源汇最短路问题-具有多个源点"></a>多源汇最短路问题-具有多个源点</h3><p>Floyd算法是一种用于计算图中所有顶点对之间最短路径的算法。它适用于稠密图，并且可以在O(N^3)的时间复杂度内完成计算，实现起来相对简单。以下是对Floyd算法的详细解释：</p>
<h4 id="Floyd算法概述"><a href="#Floyd算法概述" class="headerlink" title="Floyd算法概述"></a>Floyd算法概述</h4><p>Floyd算法通过动态规划的方式，逐步构建出从任意两个顶点之间的最短路径。它的核心思想是逐步考虑经过越来越多数量的中间顶点的最短路径。</p>
<h4 id="算法逻辑"><a href="#算法逻辑" class="headerlink" title="算法逻辑"></a>算法逻辑</h4><ol>
<li><p><strong>定义状态</strong>：定义<code>D[k, i, j]</code>表示“经过编号不超过<code>k</code>的节点”从顶点<code>i</code>到顶点<code>j</code>的最短路径长度。</p>
</li>
<li><p><strong>状态转移</strong>：问题可以划分为两个子问题：</p>
<ul>
<li>不经过编号超过<code>k-1</code>的节点从<code>i</code>到<code>j</code>的最短路径。</li>
<li>经过顶点<code>k</code>，即先从<code>i</code>到<code>k</code>，再从<code>k</code>到<code>j</code>的最短路径。</li>
</ul>
<p>状态转移方程为：<br>[ D[k, i, j] &#x3D; \min(D[k - 1, i, j], D[k - 1, i, k] + D[k - 1, k, j]) ]</p>
</li>
<li><p><strong>初始状态</strong>：初始时，<code>D[0, i, j]</code>等于邻接矩阵<code>A[i][j]</code>，其中<code>A</code>表示图的邻接矩阵。</p>
</li>
</ol>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><ol>
<li><p><strong>初始化</strong>：使用邻接矩阵<code>A</code>直接初始化<code>D</code>矩阵。</p>
</li>
<li><p><strong>动态规划</strong>：进行三层循环，最外层循环变量<code>k</code>表示当前考虑的中间顶点的数量，内层循环变量<code>i</code>和<code>j</code>分别表示起点和终点。</p>
</li>
<li><p><strong>状态更新</strong>：在最外层循环到<code>k</code>时，内层循环更新状态转移：<br>[ D[i, j] &#x3D; \min(D[i, j], D[i, k] + D[k, j]) ]</p>
</li>
<li><p><strong>最终结果</strong>：最终，<code>D[i, j]</code>将保存从顶点<code>i</code>到顶点<code>j</code>的最短路径长度。</p>
</li>
</ol>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>Floyd算法的循环顺序很重要，很多初学者按照<code>j, k</code>的顺序执行循环可能会得到错误的结果，因为状态<code>D[i, j]</code>依赖于<code>D[i, k]</code>和<code>D[k, j]</code>，而这两个状态在<code>k</code>的循环中是先于<code>j</code>更新的。</p>
</li>
<li><p>Floyd算法的本质是动态规划，通过逐步增加中间顶点的数量来逼近最终的最短路径。</p>
</li>
<li><p>与背包问题的状态转移方程类似，<code>k</code>这一维可以被省略，直接使用<code>D</code>矩阵进行状态转移。</p>
</li>
</ul>
<p>通过上述步骤，Floyd算法能够有效地计算出图中任意两点间的最短路径。</p>
<h5 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="传递闭包问题"><a href="#传递闭包问题" class="headerlink" title="传递闭包问题"></a>传递闭包问题</h4><p>在交际网络中，我们通常有一系列元素和它们之间的二元关系，这些关系具有传递性。这意味着如果元素A与元素B有关系，元素B与元素C也有关系，那么可以推断出元素A与元素C之间也存在关系。基于这种传递性，我们可以通过推导来找出尽可能多的元素间隐含的关系，这个过程称为构建传递闭包。</p>
<p>为了解决这个问题，我们可以建立一个邻接矩阵<code>d</code>，其中<code>d[i][j] = 1</code>表示元素<code>i</code>与元素<code>j</code>之间存在关系，<code>d[i][j] = 0</code>则表示它们之间没有直接关系。特别地，对于每个元素<code>i</code>，<code>d[i][i]</code>始终为1，表示元素自身与自身总是存在关系。</p>
<p>使用Floyd算法可以有效地解决传递闭包问题。Floyd算法通过动态规划逐步构建出所有元素对之间的最短路径，这个过程实际上就是在计算传递闭包。通过Floyd算法，我们可以填充邻接矩阵，最终得到一个完整的传递闭包矩阵，其中包含了所有元素对之间是否存在关系（即是否可以通过其他元素间接相连）的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">boo1 d[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	cin &gt;&gt;n &gt;&gt;m</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)d[i][i]<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		d[x][y]=d[y][x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="number">1</span>nt1=<span class="number">1</span>;i&lt;=n;<span class="number">1</span>++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">				d[i][j]|=d[i][k]&amp;d[k][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/05/25/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC11%E8%AE%B2/%E6%9C%80%E7%9F%AD%E8%B7%AF/" data-id="cm23pcg0s0001362z36lgakfr" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/05/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E8%AE%B2/cz/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E8%AE%B2/%E8%B4%AA%E5%BF%83%E8%A7%A3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC6%E8%AE%B2/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC7%E8%AE%B2/%E7%BA%BF%E6%AE%B5%E6%A0%91/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="0-1背包问题介绍在0-1背包问题中，你有N件物品和一个容量为V的背包。每件物品都有各自的体积和价值，且每件物品只能选择一次。目标是在不超过背包容量的前提下，最大化装入背包的物品总价值。 动态规划解法动态规划是一种通过分解问题、记住中间结果来解决复杂问题的方法。对于0-1背包问题，我们可以通过以下步骤使用动态规划求解：  状态定义：定义状态f[i][j]表示在前i个物品中，使用容量至多为j的背包时">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="0-1背包问题介绍在0-1背包问题中，你有N件物品和一个容量为V的背包。每件物品都有各自的体积和价值，且每件物品只能选择一次。目标是在不超过背包容量的前提下，最大化装入背包的物品总价值。 动态规划解法动态规划是一种通过分解问题、记住中间结果来解决复杂问题的方法。对于0-1背包问题，我们可以通过以下步骤使用动态规划求解：  状态定义：定义状态f[i][j]表示在前i个物品中，使用容量至多为j的背包时">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-09-26T06:10:50.000Z">
<meta property="article:modified_time" content="2024-09-26T06:10:50.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-课编程/第8讲/背包模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2024-09-26T06:10:50.000Z" itemprop="datePublished">2024-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="0-1背包问题介绍"><a href="#0-1背包问题介绍" class="headerlink" title="0-1背包问题介绍"></a>0-1背包问题介绍</h3><p>在0-1背包问题中，你有<strong>N</strong>件物品和一个容量为<strong>V</strong>的背包。每件物品都有各自的体积和价值，且每件物品只能选择一次。目标是在不超过背包容量的前提下，最大化装入背包的物品总价值。</p>
<h4 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h4><p>动态规划是一种通过分解问题、记住中间结果来解决复杂问题的方法。对于0-1背包问题，我们可以通过以下步骤使用动态规划求解：</p>
<ol>
<li><p><strong>状态定义</strong>：定义状态<code>f[i][j]</code>表示在前<strong>i</strong>个物品中，使用容量至多为<strong>j</strong>的背包时，能获得的最大价值。</p>
</li>
<li><p>m&#x3D;5,f[1][2];&#x2F;&#x2F;前1个物品，花费了两个容量获得的最大价值；f[2][3]</p>
</li>
<li><p><strong>状态转移方程</strong>：</p>
<ul>
<li><p>如果背包容量<strong>j</strong>小于第<strong>i</strong>件物品的体积<code>v[i]</code>，则第<strong>i</strong>件物品无法被选中，因此状态<code>f[i][j]</code>等于<code>f[i - 1][j]</code>。</p>
</li>
<li><p>如果背包容量足够，我们需要在携带和不携带第<strong>i</strong>件物品之间做出选择：</p>
<ul>
<li>携带第<strong>i</strong>件物品，价值为<code>f[i - 1][j - v[i]] + w[i]</code>。</li>
<li>不携带第<strong>i</strong>件物品，价值为<code>f[i - 1][j]</code>。</li>
</ul>
<p>​    我们选择两者中的最大值作为<code>f[i][j]</code>的值。</p>
</li>
</ul>
</li>
<li><p><strong>初始化和边界条件</strong>：<code>f[0][0] = 0</code>，表示没有物品或零容量时，价值为零。</p>
</li>
<li><p><strong>计算顺序</strong>：由于状态<code>f[i][j]</code>依赖于之前的状态，我们需要按照物品序号或背包容量的顺序进行计算。</p>
</li>
</ol>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>提供了几种不同的代码实现方式：</p>
<h5 id="版本1：二维DP数组"><a href="#版本1：二维DP数组" class="headerlink" title="版本1：二维DP数组"></a>版本1：二维DP数组</h5><p>使用两个嵌套循环，外循环遍历物品，内循环遍历背包容量。这种方式需要一个二维数组来存储中间状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[MAXN];    <span class="comment">// 价值</span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int f[2][MAXN];</span></span><br><span class="line"><span class="comment">int cnt=0;</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">   for(int j=1;j&lt;=m;j++)&#123;</span></span><br><span class="line"><span class="comment">       if(j&lt;v[i])</span></span><br><span class="line"><span class="comment">       f[cnt][j]=f[1-cnt][j];</span></span><br><span class="line"><span class="comment">       else f[cnt][j]=max(f[1-cnt][j],f[1-cnt][j-v[i]]+w[i]);</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   cnt=1-cnt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i])</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="版本2：一维DP数组"><a href="#版本2：一维DP数组" class="headerlink" title="版本2：一维DP数组"></a>版本2：一维DP数组</h5><p>通过观察发现，我们只需要最终状态<code>f[n][m]</code>，因此可以将状态优化到一维数组<code>f[j]</code>。由于状态更新依赖于之前的决策，我们需要逆序遍历背包容量，以避免使用已经被更新的状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; v[i])</span><br><span class="line">            f[j] = f[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="版本3：优化输入"><a href="#版本3：优化输入" class="headerlink" title="版本3：优化输入"></a>版本3：优化输入</h5><p>进一步优化，我们可以在输入物品信息的同时进行状态更新，这样可以减 	少所需的存储空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN];  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;      <span class="comment">// 边输入边处理    </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>0-1背包问题是理解动态规划思想的一个很好的例子。通过定义清晰的阶段、状态和状态转移方程，以及合理地组织计算顺序，我们可以高效地解决这类问题。代码示例提供了从基础到优化的多种实现方法，有助于深入理解0-1背包问题的解决策略。</p>
<h3 id="完全背包问题概述"><a href="#完全背包问题概述" class="headerlink" title="完全背包问题概述"></a>完全背包问题概述</h3><p>完全背包问题是一种组合优化问题。你有<strong>N</strong>种不同的物品，每种物品都有无限件可用，以及一个容量为<strong>V</strong>的背包。每个物品都有一个体积<strong>vi</strong>和一个价值<strong>wi</strong>。目标是选择物品来装满背包，使得背包内的总体积不超过背包的容量，同时背包内的总价值最大。</p>
<h5 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h5><ul>
<li><strong>输入</strong>：第一行包含两个整数<strong>N</strong>和<strong>V</strong>，分别表示物品的数量和背包的容积。之后有<strong>N</strong>行，每行包含两个整数<strong>vi</strong>和<strong>wi</strong>，分别表示每种物品的体积和价值。</li>
<li><strong>输出</strong>：输出一个整数，表示能够装入背包的最大价值。</li>
</ul>
<h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><ul>
<li><strong>N</strong>, <strong>V</strong> ≤ 1000</li>
<li><strong>vi</strong>, <strong>wi</strong> ≤ 1000</li>
</ul>
<h4 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h4><p>完全背包问题可以使用动态规划解决。我们定义一个二维数组<strong>f[i][j]<strong>，其中</strong>f[i][j]<strong>表示在考虑前</strong>i</strong>种物品的情况下，背包容量为<strong>j</strong>时的最大价值。</p>
<p>状态转移方程如下：<br>$f[i][j] &#x3D; \max(f[i-1][j], f[i-1][j-k \cdot v[i]] + k \cdot w[i]) $<br>其中<strong>k</strong>是物品<strong>i</strong>的选取次数，且<strong>k</strong>可以从0到**j &#x2F; v[i]**。</p>
<h3 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h3><p>以下是代码的核心逻辑：</p>
<ol>
<li><p><strong>初始化</strong>：创建一个二维数组<strong>f</strong>，大小为<strong>N+1</strong> × <strong>M+1</strong>，用于存储动态规划过程中的中间结果。</p>
</li>
<li><p><strong>填充物品信息</strong>：遍历每种物品，读取其体积和价值。</p>
</li>
<li><p><strong>动态规划</strong>：使用嵌套循环，外循环遍历物品，内循环遍历背包容量。对于每个物品，我们检查所有可能的容量值，更新**f[i][j]**的值。</p>
</li>
<li><p><strong>状态更新</strong>：对于每个物品<strong>i</strong>和每个容量<strong>j</strong>，我们计算不选择物品<strong>i</strong>（即<strong>f[i-1][j]<strong>）和选择物品</strong>i</strong>多次（通过<strong>k</strong>循环）的最大价值，然后取两者的最大值作为**f[i][j]**的值。</p>
</li>
<li><p><strong>输出结果</strong>：最终，**f[N][V]**将包含最大价值，将其输出。</p>
</li>
</ol>
<h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>通过观察状态转移方程，我们可以发现不需要<strong>k</strong>循环，因为对于每个物品<strong>i</strong>和容量<strong>j</strong>，我们只需要考虑最后一次选择物品<strong>i</strong>的情况。这将问题简化为：<br>$ f[i][j] &#x3D; \max(f[i][j-v[i]] + w[i], f[i-1][j]) $</p>
<h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><p>最终的优化代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N], v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; j++) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>完全背包问题通过动态规划可以有效解决。关键在于正确定义状态、状态转移方程，并进行适当的优化以提高算法效率。</p>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><p>多重背包是指每个物品有很多的数量。大概有三种方式，第一种是当作01背包写，第二种是通过二进制优化来枚举数量，第三种是&#x3D;&#x3D;单调队列优化&#x3D;&#x3D;。</p>
<p>19</p>
<p>1      1</p>
<p>2    10</p>
<p>4   100</p>
<p>8  1000</p>
<p>4</p>
<p>&#x3D;&#x3D;多重背包的单调队列优化在单调队列那章所讲&#x3D;&#x3D;</p>
<p>下面是朴素做法的代码</p>
<p>时间复杂度：O(n×m×s)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span><span class="number">+10</span>, M = <span class="number">6000</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i]; ++ k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - k * v[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="二进制优化的理解"><a href="#二进制优化的理解" class="headerlink" title="二进制优化的理解"></a>二进制优化的理解</h3><p><strong>二进制优化的必要性</strong>：<br>直接对每种物品的每种可能数量进行遍历将导致时间复杂度为O(n^3^)，这在大规模数据下是不可行的。二进制优化可以将时间复杂度降低到O(n^2^* logS)，其中S是每种物品数量的最大限制。</p>
<p><strong>二进制优化的核心思想</strong>：<br>利用二进制表示法来减少状态转移的复杂性。任何正整数都可以表示为二进制形式，即一系列2的幂的和。在多重背包问题中，这意味着每种物品的不同数量可以通过二进制表示来分解。</p>
<h3 id="二进制优化步骤"><a href="#二进制优化步骤" class="headerlink" title="二进制优化步骤"></a>二进制优化步骤</h3><ol>
<li><p><strong>分组</strong>：将每种物品的不同数量分为若干组，每组包含2的幂的数量。例如，如果一种物品最多可以选择10个，那么可以将其分为5组：1个、2个、4个、8个和剩余的数量。</p>
</li>
<li><p><strong>状态转移</strong>：对于每组物品，我们只需要考虑是否选择这组物品，而不是单个物品。这样，状态转移方程简化为类似于0-1背包问题的形式。</p>
</li>
<li><p><strong>计算最大价值</strong>：通过一维动态规划数组，从背包容量为0开始向上更新，直到达到最大容量。</p>
</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>二进制优化的C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12010</span>, M = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N]; <span class="comment">// 逐一枚举最大是N*logS</span></span><br><span class="line"><span class="type">int</span> f[M]; <span class="comment">// 体积&lt;M</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 分组的组别</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>; <span class="comment">// 组别里面的个数</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt;= s) &#123;</span><br><span class="line">            cnt++; <span class="comment">// 分组增加</span></span><br><span class="line">            v[cnt] = a * k; <span class="comment">// 整体体积</span></span><br><span class="line">            w[cnt] = b * k; <span class="comment">// 整体价值</span></span><br><span class="line">            s -= k; <span class="comment">// s减小</span></span><br><span class="line">            k *= <span class="number">2</span>; <span class="comment">// 组别里的个数增加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩余的一组</span></span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = cnt; <span class="comment">// 枚举次数由个数变成组别数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 01背包一维优化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二进制优化是一种有效的策略，用于解决多重背包问题中的大规模数据。通过将每种物品的不同数量分组，并利用二进制表示法来减少状态转移的复杂性，我们可以显著提高算法的效率。这种方法将问题转化为多个0-1背包问题的实例，每个实例对应于一组特定数量的物品，从而简化了问题并减少了计算量。</p>
<p>f[i]&#x3D;&#x3D;f[i][x]</p>
<p>f[i][x]&#x3D;max(f[i][x-1],f[i+(1&lt;&lt;(x-1))][x-1])</p>
<p>x&#x3D;log(m)</p>
<h3 id="混合背包问题概述"><a href="#混合背包问题概述" class="headerlink" title="混合背包问题概述"></a>混合背包问题概述</h3><p>在混合背包问题中，有<strong>N</strong>种物品和一个容量为<strong>V</strong>的背包。物品分为三类：</p>
<ol>
<li><strong>第一类</strong>：只能用1次（0-1背包问题）。</li>
<li><strong>第二类</strong>：可以用无限次（完全背包问题）。</li>
<li><strong>第三类</strong>：最多只能用<strong>si</strong>次（多重背包问题）。</li>
</ol>
<p>每种物品的体积是<strong>vi</strong>，价值是<strong>wi</strong>。问题的目标是选择物品装入背包，使得物品体积总和不超过背包容量，且价值总和最大。</p>
<h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p>状态<strong>f(i,j)<strong>表示从前</strong>i</strong>个物品中选取，总体积不超过<strong>j</strong>的所有选法的集合。</p>
<h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p>根据不同的物品类型，状态转移方程如下：</p>
<ul>
<li><strong>0-1背包</strong>：$f(i,j) &#x3D; \max(f(i-1,j), f(i-1,j-v)+w) $。</li>
<li><strong>完全背包</strong>：$f(i,j) &#x3D; \max(f(i-1,j), f(i,j-v)+w) $。</li>
<li><strong>多重背包</strong>：$ f(i,j) &#x3D; \max(f(i-1,j), f(i-1,j-v)+w, f(i-1,j-2v)+2w, \ldots) $。</li>
</ul>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>混合背包问题的时间复杂度为 $ O(N \times V \times \sum log_2 s_i) $，其中<strong>si</strong>是第三类物品的使用次数限制。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>以下是混合背包问题的C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, f[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (!s) &#123; <span class="comment">// 完全背包问题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = v; j &lt;= m; j++) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="number">-1</span>) s = <span class="number">1</span>; <span class="comment">// 0-1背包问题</span></span><br><span class="line">            <span class="comment">// 完全背包问题转化为01背包问题，二进制拆分优化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k *= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= k * v; j--) &#123;</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - k * v] + k * w);</span><br><span class="line">                &#125;</span><br><span class="line">                s -= k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= s * v; j--) &#123;</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - s * v] + s * w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>混合背包问题通过结合不同类型的背包问题，提供了一个更为通用的框架来处理背包问题的各种变体。通过适当的状态转移和优化，可以有效地解决这类问题，并找到最大价值的解决方案。</p>
<h3 id="分组背包问题概述"><a href="#分组背包问题概述" class="headerlink" title="分组背包问题概述"></a>分组背包问题概述</h3><p>分组背包问题是一种特殊的背包问题，其中物品被分为<strong>N</strong>组，每组内的物品可以看作是相似的，但每组内只能选择一个物品。每个物品有特定的体积<strong>vij</strong>和价值<strong>wij</strong>，其中<strong>i</strong>是组号，<strong>j</strong>是组内物品的编号。目标是选择一些物品装入容量为<strong>V</strong>的背包，使得总体积不超过背包容量，同时总价值最大。</p>
<h4 id="状态表示-1"><a href="#状态表示-1" class="headerlink" title="状态表示"></a>状态表示</h4><p>状态<strong>f(i,j)<strong>表示从前</strong>i</strong>个组中选取，且总体积不超过<strong>j</strong>的所有选法的集合。</p>
<h4 id="状态计算-1"><a href="#状态计算-1" class="headerlink" title="状态计算"></a>状态计算</h4><p>状态转移方程如下：</p>
<ol>
<li>如果不选择第<strong>i</strong>组中的任何物品，状态转移为**f(i-1,j)**。</li>
<li>如果选择第<strong>i</strong>组中的第<strong>k</strong>个物品，状态转移为<strong>f(i-1,j-vij)+wij</strong>。</li>
</ol>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>由于需要对每组内的物品进行遍历，并对每组使用一次背包问题的状态转移，时间复杂度为<strong>O(N×V×S)<strong>，其中</strong>S</strong>是每组内物品的数量。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>以下是分组背包问题的C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[N][N], w[N][N], f[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j++) &#123;</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k++) &#123; <span class="comment">// 组内编号</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= v[i][k]) &#123;</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分组背包问题通过将物品分组，并在每组内独立应用背包问题的状态转移，可以有效地找到最大价值的解决方案。这种方法允许我们处理更为复杂的背包问题变体，其中物品的选择受到组内限制。通过适当的状态转移和优化，可以提高算法的效率，解决实际问题。</p>
<h3 id="0-1背包问题求方案数概述"><a href="#0-1背包问题求方案数概述" class="headerlink" title="0-1背包问题求方案数概述"></a>0-1背包问题求方案数概述</h3><p>在0-1背包问题中，给定<strong>N</strong>件物品和一个容量为<strong>V</strong>的背包。每件物品只能使用一次，每件物品的体积是<strong>vi</strong>，价值是<strong>wi</strong>。除了求解最大价值外，我们还希望找到所有可能的最优解方案数。</p>
<h4 id="状态表示-2"><a href="#状态表示-2" class="headerlink" title="状态表示"></a>状态表示</h4><ul>
<li><strong>f(i,j)</strong> 表示从<strong>i</strong>个物品中选择，且总体积不超过<strong>j</strong>时的最大价值。</li>
<li><strong>cnt(i,j)</strong> 表示从<strong>i</strong>个物品中选择，且总体积恰好为<strong>j</strong>时的方案数。</li>
</ul>
<h4 id="状态计算-2"><a href="#状态计算-2" class="headerlink" title="状态计算"></a>状态计算</h4><p>状态转移方程如下：</p>
<ul>
<li><strong>f(j)</strong> 更新为 <code>max(f(j), f(j-v)+w)</code>，其中 <strong>v</strong> 和 <strong>w</strong> 是当前考虑的物品体积和价值。</li>
<li><strong>cnt(j)</strong> 的更新取决于 <strong>f(j)</strong> 是如何更新的：<ul>
<li>如果 <strong>f(j)</strong> 通过不选择当前物品更新（即 **f(j) &#x3D; f(j-1)**），则 **cnt(j) &#x3D; cnt(j-1)**。</li>
<li>如果 <strong>f(j)</strong> 通过选择当前物品更新（即 <strong>f(j) &#x3D; f(j-v)+w</strong>），则 **cnt(j) &#x3D; cnt(j-v)**。</li>
<li>如果 <strong>f(j)</strong> 可以由两种方式得到，则 **cnt(j) &#x3D; cnt(j-1) + cnt(j-v)**。</li>
</ul>
</li>
</ul>
<h4 id="初始条件"><a href="#初始条件" class="headerlink" title="初始条件"></a>初始条件</h4><ul>
<li><strong>f(0)</strong> 初始化为0，表示没有任何物品时背包的价值为0。</li>
<li><strong>cnt(0)</strong> 初始化为1，表示空背包（不选择任何物品）是一种方案。</li>
</ul>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>算法的时间复杂度为 <strong>O(N×V)<strong>，其中 <strong>N</strong> 是物品数量，</strong>V</strong> 是背包容量。</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p>以下是0-1背包问题求方案数的C++代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1100</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, f[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cnt[i] = <span class="number">1</span>; <span class="comment">// 初始化方案数，什么都不选是一种方案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[j] &lt; f[j - v] + w) &#123;</span><br><span class="line">                f[j] = f[j - v] + w;</span><br><span class="line">                cnt[j] = cnt[j - v];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f[j] == f[j - v] + w) &#123;</span><br><span class="line">                cnt[j] = (cnt[j] + cnt[j - v]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt[m] &lt;&lt; endl; <span class="comment">// 输出最优解的方案数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>0-1背包问题求方案数涉及到在找到最大价值的同时，记录和计算达到该价值的所有可能方案。通过维护一个额外的数组来跟踪方案数，我们可以在最终输出最优解的方案总数。这种方法可以应用于更复杂的背包问题变体，以提供关于最优解的更多信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/" data-id="cm23pcg0w000s362z7qhs0r8a" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E8%AE%B2/%E8%B4%AA%E5%BF%83%E8%A7%A3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC6%E8%AE%B2/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E8%AE%B2/%E8%B4%AA%E5%BF%83%E8%A7%A3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC8%E8%AE%B2/%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/09/26/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC6%E8%AE%B2/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E8%AF%BE%E7%BC%96%E7%A8%8B/%E7%AC%AC7%E8%AE%B2/%E7%BA%BF%E6%AE%B5%E6%A0%91/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>